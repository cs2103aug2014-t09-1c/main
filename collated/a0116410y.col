//@author: a0116410y



	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\ccombobox.cpp
	 */

#include "ccombobox.h"
#include <QLineEdit>

CComboBox::CComboBox()
{

}

CComboBox::CComboBox(QGroupBox *par)
{
    setParent(par);
    setEditable(true);
    lineEdit()->setStyleSheet("QLineEdit {padding: 2px ; border-image: url(:/Button/Resources/BORDER_COMBO.png);}");
    lineEdit()->setFont(QFont("Segoe UI", 15));
    connect(this, SIGNAL(editTextChanged(QString)),this,SLOT(textChanged(QString)));
}

void CComboBox::textChanged(QString edit)
{
    showPopup();
    setEditable(true);
}

	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\ccombobox.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\ccompleter.cpp
	 */

#include "ccompleter.h"
#include <QAbstractItemView>

CCompleter::CCompleter()
{
}

CCompleter::CCompleter(const QStringList& words, QObject * parent) :
QCompleter(parent), m_list(words), m_model()
{
    setModel(&m_model);
    popup()->setFont(QFont("Segoe UI", 13));
}

void CCompleter::update(QStringList suggestions)
{
	QStringList filtered = suggestions;
    m_model.setStringList(filtered);
    complete();
}

QString CCompleter::word()
{
    return m_word;
}

	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\ccompleter.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\clineedit.cpp
	 */

#include "clineedit.h"
#include <QAbstractItemView>
#include "ui_mainwindow.h"
#include "QLabel"

using namespace std;

CLineEdit::CLineEdit(QWidget *parent)
: QLineEdit(parent), c(0)
{
    setFont(QFont("Segoe UI", 15));
    CCompleter * completer = new CCompleter(QStringList(), this);
    completer->setCaseSensitivity(Qt::CaseInsensitive);
    setCompleter(completer);
    connect(this, SIGNAL(returnPressed()),this, SLOT(sendToParser()));
	connect(this, SIGNAL(toSetText(const QString&)), this, SLOT(setText(const QString&)));
}

CLineEdit::~CLineEdit()
{
}

void CLineEdit::sendToParser()
{
	QString originalText = text();
	string inputText = originalText.toUtf8().constData();
	emit sendText(inputText);
	clear();
	emit emitFeedback(originalText, true);
}

void CLineEdit::setCompleter(CCompleter *completer)
{
    if (c){
        QObject::disconnect(c, 0, this, 0);
    }

        c = completer;

    if (!c){
        return;
    }

    c->setWidget(this);
	connect(completer, SIGNAL(activated(const QString&)), this, SLOT(insertCompletion(const QString&)));
}

CCompleter *CLineEdit::completer() const
{
    return c;
}

void CLineEdit::insertCompletion(const QString & completion)
{
	string choiceString = completion.toUtf8().constData();
	string inputText = text().toUtf8().constData();
	emit emitSuggestionSelected(choiceString, inputText);
    QString& s = QString("");
    setText(s);
    //selectAll();
}


void CLineEdit::keyPressEvent(QKeyEvent *e)
{
	switch (e->key())
	{
		case Qt::Key_Semicolon:
			e->ignore();		
			moveToNextEntry();
			return;
	}
	if (c && c->popup()->isVisible() && c->popup()->currentIndex().row() >= 0) {
    // The following keys are forwarded by the completer to the widget
        switch (e->key())
        {
            case Qt::Key_Enter:
            case Qt::Key_Return:
            case Qt::Key_Escape:
            case Qt::Key_Tab:
            case Qt::Key_Backtab:
			e->ignore();
			return;				// Let the completer do default behaviour
        }
    }
    bool isShortcut = (e->modifiers() & Qt::ControlModifier) && e->key() == Qt::Key_E;
    if (!isShortcut)
    QLineEdit::keyPressEvent(e); // Don't send the shortcut (CTRL-E) to the text edit.

    if (!c) {
        return;
    }

    bool ctrlOrShift = e->modifiers() & (Qt::ControlModifier | Qt::ShiftModifier);
    if (!isShortcut && !ctrlOrShift && e->modifiers() != Qt::NoModifier) {
        c->popup()->hide();
        return;
    }

	emit emitFeedback(text(), false);
    c->popup()->setCurrentIndex(c->completionModel()->index(-1, 0));
}

void CLineEdit::updateCompleter(QStringList suggestions)
{
	c->update(suggestions);
}

void CLineEdit::updateLineText(string text)
{
	const QString string = QString::fromStdString(text);
	emit toSetText(string);
	moveToNextEntry();
}

void CLineEdit::moveToNextEntry()
{
	QString openingType = "[";
	QString closingType = "]";
	int nextEntryPos = text().indexOf(openingType, cursorPosition());
	if (nextEntryPos < 0) {
		nextEntryPos = text().indexOf(openingType, 0);
	}
	if (nextEntryPos >= 0) {
		setCursorPosition(nextEntryPos + 1);
		int entryLength = text().indexOf(closingType, cursorPosition()) - nextEntryPos;
		cursorForward(true, entryLength - 1);
	}
}

	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\clineedit.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\cmenubar.cpp
	 */

#include "cmenubar.h"
#include <QPoint>
#include <QMouseEvent>
#include <QDebug>
#include <QLabel>

CMenuBar::CMenuBar()
{
    moving = false;
}
CMenuBar::CMenuBar(QWidget *par)
{
    setParent(par);
    moving = false;
    setMouseTracking(false);
}

void CMenuBar::mousePressEvent(QMouseEvent *event)
{
    QLabel::mousePressEvent(event);
    if((event->button() == Qt::LeftButton)) {
        moving = true;
        offset = event->pos();
    }
}

void CMenuBar::mouseMoveEvent(QMouseEvent *event)
{
    QLabel::mouseMoveEvent(event);
    if(moving)
        parentWidget()->parentWidget()->move(event->globalPos() - offset);
}

void CMenuBar::mouseReleaseEvent(QMouseEvent *event)
{
    QLabel::mouseReleaseEvent(event);
    if(event->button() == Qt::LeftButton) {
        moving = false;
    }
}

	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\cmenubar.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\ctable.cpp
	 */

#include "ctable.h"
#include <QHeaderView>
#include <QTableView>
#include <QKeyEvent>
#include <vector>
#include <QPainter>

const QString& numHeader = NUMBER_HEADER;
const QString& toDoHeader = TODO_HEADER;
const QString& categoryHeader = CATEGORY_HEADER;
const QString& startHeader = START_TIME_HEADER;
const QString& endHeader = END_TIME_HEADER;
const QString& completeHeader = COMPLETE_HEADER;

CTable::CTable()
{
}
CTable::CTable(QWidget *par)
{
    setParent(par);
    setSelectionMode(QAbstractItemView::SingleSelection);
    setSelectionBehavior(QAbstractItemView::SelectRows);
	setTableFormat();
	setTableHeaders();
	setWordWrap(true);
}

void CTable::setTableFormat()
{
	initialiseHighlight();
	verticalHeader()->setVisible(false);
	verticalHeader()->setDefaultSectionSize(20);
	setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
	setColumnCount(6);
	horizontalHeader()->setSectionResizeMode(QHeaderView::Fixed);
	horizontalHeader()->setFont(QFont("Segoe UI", 8));
	setColumnWidth(NUMBER_FIELD, NUMBER_COLUMN_WIDTH);
	setColumnWidth(TODO_FIELD, TODO_COLUMN_WIDTH);
	setColumnWidth(CATEGORY_FIELD, CATEGORY_COLUMN_WIDTH);
	setColumnWidth(START_TIME_FIELD, START_TIME_COLUMN_WIDTH);
	setColumnWidth(END_TIME_FIELD, END_TIME_COLUMN_WIDTH);
	setColumnWidth(COMPLETE_FIELD, COMPLETE_COLUMN_WIDTH);
}

void CTable::setTableHeaders()
{
	QStringList header;
	header << numHeader << toDoHeader << categoryHeader << startHeader << endHeader << completeHeader;
	setHorizontalHeaderLabels(header);
}

void CTable::createTableData(vector<vector<string>> listData)
{
	vector<vector<string>> list = listData;
    clearContents();
	setRowCount(0);
    int listSize = list.size();
    for (int i = 0; i < listSize; ++i) {
        insertRow(i);
        QTableWidgetItem *num = new QTableWidgetItem(QString::number(i + 1));
		num->setFlags(num->flags() ^ Qt::ItemIsEditable);
		num->setTextAlignment(Qt::AlignCenter);
        setItem(i,NUMBER_FIELD,num);
        for (int j = 0; j < 5; ++j) {
            QString stringGet = QString::fromStdString(list[i][j]);
			stringGet = wrapLongString(stringGet);
            QTableWidgetItem *item = new QTableWidgetItem(stringGet);
			item->setFlags(item->flags() ^ Qt::ItemIsEditable);
			if (j != 0) {
				item->setTextAlignment(Qt::AlignCenter);
			}
			if (j == 4) {
				if (stringGet == "Lapsed") {
					item->setBackground(QBrush(Qt::red, Qt::FDiagPattern));
				}
			}
            setItem(i,j + 1, item);
			verticalHeader()->setSectionResizeMode(i, QHeaderView::ResizeToContents);
        }
    }
	show();
}

void CTable::initialiseHighlight()
{
    QItemSelectionModel *sm = selectionModel();
    connect (sm,SIGNAL(currentChanged(QModelIndex,QModelIndex)),this,SLOT(selectRowSlot(QModelIndex,QModelIndex)));
}

void CTable::selectRowSlot(const QModelIndex & selected, const QModelIndex & deselected)
{
    QItemSelectionModel *sm = selectionModel();
    emit sm->select(selected,QItemSelectionModel::Columns);
}

void CTable::keyPressEvent(QKeyEvent *event)
{
    QTableWidget::keyPressEvent(event);
    switch (event->key()) {
        case Qt::Key_Tab:
        event->ignore();
    }
}

QString CTable::wrapLongString(QString string)
{
	const int CriticalPos = 25;
	const QString wrapper = "-\n";
	QString iterString = string;
	QString tempString = string;
	int count = 0;
	int endlineAddCorrection = 0;

	while (count < string.length()) {
		QString firstWord = iterString.split(" ").at(0);
		QString firstNewLine = iterString.split("\n").at(0);
		if (firstWord.length() > CriticalPos && firstNewLine.length() >= firstWord.length()) {
			count += CriticalPos;
			tempString.insert(count + endlineAddCorrection, wrapper);
			endlineAddCorrection += wrapper.length();
			iterString = iterString.remove(0, CriticalPos);
		}
		else {
			int nextWordPos = min(firstWord.length(), firstNewLine.length()) + 1;
			iterString = iterString.remove(0, nextWordPos);
			count += nextWordPos;
		}
	}
	return tempString;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\ctable.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\mainwindow.cpp
	 */

#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "qscrollbar.h"

const QString initialise;

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow),
	control("GoodleStorage.txt")
{
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowMinimizeButtonHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint );
    ui->setupUi(this);
	initiateLineEditConnections();
	initiateTableWidgetConnections();
	initiateCommandLabelConnections();
	initiateConsoleOutConnections();
	initiateProgressBarConnections();
	updateTableData();
	updateConsoleOutput();
	determineCommandLabel(initialise);
}

void MainWindow::initiateLineEditConnections()
{
	connect(ui->lineEdit, SIGNAL(sendText(string)), this, SLOT(sendInputToController(string)));
	connect(ui->lineEdit, SIGNAL(emitFeedback(QString, bool)), this, SLOT(sendFeedbackToController(QString, bool)));
	connect(ui->lineEdit, SIGNAL(emitSuggestionSelected(string, string)), this, SLOT(getSuggestionResponse(string, string)));
	connect(this, SIGNAL(sendSuggestionContentsToCompleter(QStringList)), ui->lineEdit, SLOT(updateCompleter(QStringList)));
	connect(this, SIGNAL(sendToLineEditAutoComplete(string)), ui->lineEdit, SLOT(updateLineText(string)));
	connect(ui->lineEdit, SIGNAL(textChanged(const QString&)), this, SLOT(determineCommandLabel(const QString&)));
}

void MainWindow::initiateTableWidgetConnections()
{
	connect(this, SIGNAL(sendTableData(vector<vector<string>>)), ui->tableWidget, SLOT(createTableData(vector<vector<string>>)));
}

void MainWindow::initiateProgressBarConnections()
{
	connect(this, SIGNAL(sendMaxToProgressBar(int)), ui->progressBar, SLOT(setMaximum(int)));
	connect(this, SIGNAL(sendValToProgressBar(int)), ui->progressBar, SLOT(setValue(int)));
}

void MainWindow::initiateConsoleOutConnections()
{
	connect(this, SIGNAL(sendToConsoleOutput(const QString&)), ui->consoleOutput, SLOT(setText(const QString&)));
}

void MainWindow::initiateCommandLabelConnections()
{
	connect(this, SIGNAL(setCommandLabel(const QString&)), ui->commandLabel, SLOT(setText(const QString&)));
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::sendInputToController(string text)
{
	control.executeEntry(text);
	updateConsoleOutput();
	updateTableData();
}

void MainWindow::updateTableData()
{
	vector<vector<string>> tableData = control.refreshTableDisplay();
	emit sendTableData(tableData);
	getProgressBarValueAdd();
}

void MainWindow::getSuggestionResponse(string selection, string lineText)
{
	control.executeSuggestionSelection(selection, lineText);
	updateConsoleOutput();
	updateTableData();
}

void MainWindow::sendFeedbackToController(QString text, bool isEnterPressed)
{
	bool isForCompleter = false;
	QStringList suggestions;
	string inputText = text.toUtf8().constData();
	if (text.length() >= 5 && text.left(6).contains("search", Qt::CaseInsensitive)) {
		vector<string> suggestionBoxList = control.populateSuggestionBox(inputText);
		
		foreach(string str, suggestionBoxList) {
			if (!str.empty()) {
				QString string = QString::fromStdString(str);
				suggestions << string;
			}
		}
		isForCompleter = true;
	}
	emit sendSuggestionContentsToCompleter(suggestions);
	if (!isForCompleter) {
		string lineEdit = control.updateLineText(inputText, isEnterPressed);
		if (!lineEdit.empty()) {
			emit sendToLineEditAutoComplete(lineEdit);
		}
	}
	if (isEnterPressed) {
		updateConsoleOutput();
	}
}

void MainWindow::getProgressBarValueAdd()
{
	pair<int, int> stats = control.getCompletedStatToday();
	if (stats.second > 0) {
		ui->progressBar->setFormat("%v/%m");
		emit sendMaxToProgressBar(stats.second);
		emit sendValToProgressBar(stats.first);
	}
	else {
		ui->progressBar->setFormat(EMPTY_TODAY_TODO);
		emit sendMaxToProgressBar(1);
		emit sendValToProgressBar(1);
	}
}

void MainWindow::updateConsoleOutput()
{
	string output = control.getConsoleString();
	if (!output.empty()) {
		const QString consoleOut = QString::fromStdString(output);
		emit sendToConsoleOutput(consoleOut);
		control.clearConsoleString();
	}
}

void MainWindow::keyPressEvent(QKeyEvent *e)
{
	int currentPos = ui->tableWidget->verticalScrollBar()->value();
	switch (e->key())
	{
	case Qt::Key_Down:
		e->ignore();
		ui->tableWidget->verticalScrollBar()->setValue(currentPos + 1);
		return;
	case Qt::Key_Up:
		e->ignore();
		ui->tableWidget->verticalScrollBar()->setValue(currentPos - 1);
		return;
	}
}

void MainWindow::determineCommandLabel(const QString& text)
{
	QString command = text.split(" ").at(0).toLower();
	if (command == ADD_COMMAND) {
		const QString label = ADD_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else if (command == EDIT_COMMAND) {
		const QString label = EDIT_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else if (command == DELETE_COMMAND) {
		const QString label = DELETE_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else if (command == COMPLETE_COMMAND) {
		const QString label = COMPLETE_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else if (command == UNCOMPLETE_COMMAND) {
		const QString label = UNCOMPLETE_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else if (command == SEARCH_COMMAND) {
		const QString label = SEARCH_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else if (command == CLIP_COMMAND) {
		const QString label = CLIP_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else if (command == SLOT_COMMAND) {
		const QString label = SLOT_LABEL_FORMAT;
		emit setCommandLabel(label);
	}
	else {
		const QString label = COMMAND_LIST;
		emit setCommandLabel(label);
	}
}

	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t01-1c_ui\mainwindow.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c\ParsedDataDeployer.cpp
	 */

#include "stdafx.h"
#include "ParsedDataDeployer.h"
#include "AddLogic.h"
#include "DeleteLogic.h"
#include "EditLogic.h"
#include "SearchLogic.h"
#include "UndoLogic.h"
#include "CompleteLogic.h"
#include "DisplayLogic.h"

ParsedDataDeployer::ParsedDataDeployer(string fileName)
{
	this->fileName = fileName;
}

ParsedDataDeployer::ParsedDataDeployer(vector<string> testVector)
{
	isTestMode = true;
	testVectorStore = testVector;
}

ParsedDataDeployer::~ParsedDataDeployer()
{
}

void ParsedDataDeployer::executeAdd(ParsedDataPackage addPackage)
{
	try {
		if (!isTestMode) {
			AddLogic newAdd(fileName);
			BaseClassLogic * add = &newAdd;
			add->execute(addPackage.getLineEntries());
			UndoLogic::instance()->storeUndo(fileName);
		}
		else {
			AddLogic newAdd(testVectorStore);
			BaseClassLogic * add = &newAdd;
			add->execute(addPackage.getLineEntries());
			testVectorStore = add->getEntriesVector();
		}
		consoleString = COMPLETED_ADD;
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ParsedDataDeployer::executeDelete(ParsedDataPackage deletePackage, string date, vector<string> keywords, int displayCase)
{
	try {
		if (!isTestMode) {
			DeleteLogic newDelete(fileName, date, keywords, displayCase);
			BaseClassLogic * deleter = &newDelete;
			deleter->execute(deletePackage.getStartEndPositions());
			UndoLogic::instance()->storeUndo(fileName, "delete", deleter->getLinesForUndo(), deleter->getPosForUndo());
		}
		else {
			DeleteLogic newDelete(testVectorStore, date, keywords, displayCase);
			BaseClassLogic * deleter = &newDelete;
			deleter->execute(deletePackage.getStartEndPositions());
			testVectorStore = deleter->getEntriesVector();
		}
		consoleString = COMPLETED_DELETE;
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ParsedDataDeployer::executeEdit(ParsedDataPackage editPackage, string date , vector<string> keywords, int displayCase)
{
	try {
		if (!isTestMode) {
			EditLogic newEdit(fileName, date, keywords, displayCase);
			BaseClassLogic * edit = &newEdit;
			edit->execute(editPackage.getStartEndPositions(), editPackage.getLineEntries());
			UndoLogic::instance()->storeUndo(fileName, "modify", edit->getLinesForUndo(), edit->getPosForUndo());
		}
		else {
			EditLogic newEdit(testVectorStore, date, keywords, displayCase);
			BaseClassLogic * edit = &newEdit;
			edit->execute(editPackage.getStartEndPositions(), editPackage.getLineEntries());
			testVectorStore = edit->getEntriesVector();
		}
		consoleString = COMPLETED_EDIT;
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

vector<string> ParsedDataDeployer::executeSearch(string searchPackage)
{
	vector<string> keywords;
	try {
		if (!isTestMode) {
			SearchLogic newSearch(fileName);
			BaseClassLogic * search = &newSearch;
			keywords = search->createKeywords(searchPackage);
		}
		else {
			SearchLogic newSearch(testVectorStore);
			BaseClassLogic * search = &newSearch;
			keywords = search->createKeywords(searchPackage);
		}
		string size = std::to_string(keywords.size());
		consoleString = SEARCH_RESULTS(size);
		return keywords;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return keywords;
	}
}

void ParsedDataDeployer::executeUndo()
{
	if (!UndoLogic::instance()->isUndoEmpty()) {
		UndoLogic::instance()->undo(fileName);
		consoleString = COMPLETED_UNDO;
	}
	else {
		consoleString = FAILED_UNDO;
	}
}

void ParsedDataDeployer::executeRedo()
{
	if (!UndoLogic::instance()->isRedoEmpty()) {
		UndoLogic::instance()->redo(fileName);
		consoleString = COMPLETED_REDO;
	}
	else {
		consoleString = FAILED_REDO;
	}
}

void ParsedDataDeployer::executeComplete(ParsedDataPackage completePackage, string date, vector<string> keywords, int displayCase)
{
	try {
		if (!isTestMode) {
			CompleteLogic newComplete(fileName, date, keywords, displayCase);
			BaseClassLogic * completer = &newComplete;
			completer->execute(completePackage.getStartEndPositions(), COMPLETE);
			UndoLogic::instance()->storeUndo(fileName, "modify", completer->getLinesForUndo(), completer->getPosForUndo());
		}
		else {
			CompleteLogic newComplete(testVectorStore, date, keywords, displayCase);
			BaseClassLogic * completer = &newComplete;
			completer->execute(completePackage.getStartEndPositions(), COMPLETE);
			testVectorStore = completer->getEntriesVector();
		}
		consoleString = COMPLETED_COMPLETE;
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ParsedDataDeployer::executeUncomplete(ParsedDataPackage uncompletePackage, string date, vector<string> keywords, int displayCase)
{
	try {
		if (!isTestMode) {
			CompleteLogic newComplete(fileName, date, keywords, displayCase);
			BaseClassLogic * completer = &newComplete;
			completer->execute(uncompletePackage.getStartEndPositions(), UNCOMPLETE);
			UndoLogic::instance()->storeUndo(fileName, "modify", completer->getLinesForUndo(), completer->getPosForUndo());
		}
		else {
			CompleteLogic newComplete(testVectorStore, date, keywords, displayCase);
			BaseClassLogic * completer = &newComplete;
			completer->execute(uncompletePackage.getStartEndPositions(), UNCOMPLETE);
			testVectorStore = completer->getEntriesVector();
		}
		consoleString = COMPLETED_UNCOMPLETE;
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

vector<vector<string>> ParsedDataDeployer::getDisplayEvents(string date, vector<string> keywords, int displayCase)
{
	vector<vector<string>> displayEventList;
	try {
		if (!isTestMode) {
			DisplayLogic newDisplay(fileName, date, keywords, displayCase);
			BaseClassLogic * displayer = &newDisplay;
			displayEventList = displayer->displayEvents();
		}
		else {
			DisplayLogic newDisplay(testVectorStore, date, keywords, displayCase);
			BaseClassLogic * displayer = &newDisplay;
			displayEventList = displayer->displayEvents();
		}
		return displayEventList;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return displayEventList;
	}
}

string ParsedDataDeployer::executeFormatContentsToLineEdit(int position, string date, vector<string> keywords, int displayCase)
{
	string contentFormatter;
	try {
		if (!isTestMode) {
			DisplayLogic newDisplay(fileName, date, keywords, displayCase);
			BaseClassLogic * displayer = &newDisplay;
			contentFormatter = displayer->formatContentsToLineEdit(position);
		}
		else {
			DisplayLogic newDisplay(testVectorStore, date, keywords, displayCase);
			BaseClassLogic * displayer = &newDisplay;
			contentFormatter = displayer->formatContentsToLineEdit(position);
		}
		return contentFormatter;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return contentFormatter;
	}
}

pair <string, string> ParsedDataDeployer::executeGetEarliestFreeSlot(ParsedDataPackage freeSlotPackage)
{
	pair <string, string> freeSlotData;
	try {
		if (!isTestMode) {
			SearchLogic newSearch(fileName);
			BaseClassLogic * search = &newSearch;
			freeSlotData = search->getEarliestFreeSlot(freeSlotPackage.getLineEntries(), freeSlotPackage.getStartEndPositions());
		}
		else {
			SearchLogic newSearch(testVectorStore);
			BaseClassLogic * search = &newSearch;
			freeSlotData = search->getEarliestFreeSlot(freeSlotPackage.getLineEntries(), freeSlotPackage.getStartEndPositions());
		}
		return freeSlotData;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return freeSlotData;
	}
}

pair<int, int> ParsedDataDeployer::executeGetTodayCompletionStat(string todayDate)
{
	pair<int, int> completionStat;
	try {
		if (!isTestMode) {
			SearchLogic newSearch(fileName);
			BaseClassLogic * search = &newSearch;
			completionStat = search->getTodayCompletionStat(todayDate);
		}
		else {
			SearchLogic newSearch(testVectorStore);
			BaseClassLogic * search = &newSearch;
			completionStat = search->getTodayCompletionStat(todayDate);
		}
		return completionStat;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return completionStat;
	}
}

string ParsedDataDeployer::returnConsoleString()
{
	return consoleString;
}

void ParsedDataDeployer::clearConsoleString()
{
	consoleString.clear();
}

vector<string> ParsedDataDeployer::returnTestVector()
{
	return testVectorStore;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c\ParsedDataDeployer.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c\ProgramController.cpp
	 */

#include "stdafx.h"
#include "ProgramController.h"
#include "ParsedDataDeployer.h"
#include "ParsedDataPackage.h"
#include <vector>
#include "CompleteParser.h"

//after an input is scanned by UI method, call to method sendToParse is made to send input to Parser
//after Parser returns the variables in ParsedDataPackage, send the details to logic
//after file output returns an output, controller sends it to UI

ProgramController::ProgramController(string fileName) : deployer(fileName)
{
	this->fileName = fileName;
	file.open(fileName, ios::out | ios::app);
	file << "";
	displayDate = getTodayDateInString();
	consoleString = WELCOME_MESSAGE;
}

ProgramController::ProgramController(vector<string> testVector) : deployer(testVector)
{
	isTestMode = true;
	displayDate = getTodayDateInString();
}

ProgramController::~ProgramController()
{
	if (!isTestMode) {
		file.close();
	}
}

void ProgramController::executeEntry(string input)
{
	clearConsoleString();
	CommandAndArgumentParser inputParse(input);

	command = inputParse.getCommand();
	arguments = inputParse.getArguments();

	if (command == HOME_COMMAND) {
		executeHomeCommand();
	}
	else if (command == ALL_COMMAND) {
		executeAllCommand();
	}
	else if (command == ADD_COMMAND) {
		executeAddCommand();
	}
	else if (command == EDIT_COMMAND){
		executeEditCommand();
	}
	else if (command == DELETE_COMMAND){
		executeDeleteCommand();
	}
	else if (command == SEARCH_COMMAND){
		executeSearchCommand();
	}
	else if (command == UNDO_COMMAND){
		executeUndoCommand();
	}
	else if (command == REDO_COMMAND){
		executeRedoCommand();
	}
	else if (command == COMPLETE_COMMAND){
		executeCompleteCommand();
	}
	else if (command == UNCOMPLETE_COMMAND){
		executeUncompleteCommand();
	}
	else if (command == SLOT_COMMAND) {
		//This will be handled by updateLineText(). This will ensure exception does not occur.
	}
	else if (command == CLIP_COMMAND) {
		updateLineText(input, true);
	}
	else {
		executeAddNaturalParsing(input);
	}
}

void ProgramController::executeHomeCommand()
{
	displayCase = DISPLAY_HOME_CASE;
	searchKeywords.clear();
	consoleString = DISPLAY_CHANGE;
}

void ProgramController::executeAllCommand()
{
	displayCase = DISPLAY_ALL_CASE;
	searchKeywords.clear();
	consoleString = DISPLAY_CHANGE;
}

void ProgramController::executeAddCommand()
{
	try {
		AddParser addParsing;
		BaseClassParser * addParse = &addParsing;
		dataPackage = addParse->parseAndReturn(arguments);
		deployer.executeAdd(dataPackage);
		consoleString = deployer.returnConsoleString();
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}
void ProgramController::executeEditCommand()
{
	try {
		EditParser editParsing;
		BaseClassParser * editParse = &editParsing;
		dataPackage = editParse->parseAndReturn(arguments);
		deployer.executeEdit(dataPackage, displayDate, searchKeywords, displayCase);
		consoleString = deployer.returnConsoleString();
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ProgramController::executeDeleteCommand()
{
	try {
		DeleteParser deleteParsing;
		BaseClassParser * deleteParse = &deleteParsing;
		dataPackage = deleteParse->parseAndReturn(arguments);
		deployer.executeDelete(dataPackage, displayDate, searchKeywords, displayCase);
		consoleString = deployer.returnConsoleString();
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ProgramController::executeSearchCommand()
{
	try {
		SearchParser searchParsing;
		BaseClassParser * searchParse = &searchParsing;
		string argument = searchParse->parseSearchArgs(arguments);
		searchKeywords = deployer.executeSearch(argument);
		consoleString = deployer.returnConsoleString();
		if (!searchKeywords.empty()) {
			displayCase = DISPLAY_KEYWORD_CASE;
		}
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ProgramController::executeUndoCommand()
{
	deployer.executeUndo();
	consoleString = deployer.returnConsoleString();
}

void ProgramController::executeRedoCommand()
{
	deployer.executeRedo();
	consoleString = deployer.returnConsoleString();
}

void ProgramController::executeCompleteCommand()
{
	try {
		CompleteParser completeParsing;
		BaseClassParser * completeParse = &completeParsing;
		dataPackage = completeParse->parseAndReturn(arguments);
		deployer.executeComplete(dataPackage, displayDate, searchKeywords, displayCase);
		consoleString = deployer.returnConsoleString();
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ProgramController::executeUncompleteCommand()
{
	try {
		CompleteParser completeParsing;
		BaseClassParser * completeParse = &completeParsing;
		dataPackage = completeParse->parseAndReturn(arguments);
		deployer.executeUncomplete(dataPackage, displayDate, searchKeywords, displayCase);
		consoleString = deployer.returnConsoleString();
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

void ProgramController::executeAddNaturalParsing(string input)
{
	try {
		AddParser addParsing;
		BaseClassParser * addParse = &addParsing;
		dataPackage = addParse->parseNLAndReturn(input);
		deployer.executeAdd(dataPackage);
		consoleString = deployer.returnConsoleString();
	}
	catch (const exception& ex){
		consoleString = ex.what();
	}
}

vector<string> ProgramController::populateSuggestionBox(string input)
{
	CommandAndArgumentParser inputParse(input);

	command = inputParse.getCommand();
	arguments = inputParse.getArguments();

	vector<string> suggestions;

	if (command == SEARCH_COMMAND) {
		SearchParser searchParsing;
		BaseClassParser * searchParse = &searchParsing;
		string argument = searchParse->parseSearchArgs(arguments);
		suggestions = deployer.executeSearch(argument);
	}
	return suggestions;
}

void ProgramController::executeSuggestionSelection(string selection, string lineText)
{
	CommandAndArgumentParser inputParse(lineText);
	string command = inputParse.getCommand();

	if (command == SEARCH_COMMAND) {
		searchKeywords.clear();
		searchKeywords.push_back(selection);
		displayCase = DISPLAY_KEYWORD_CASE;
		consoleString = SELECT_KEYWORD;
	}
	refreshTableDisplay();
}

vector<vector<string>> ProgramController::refreshTableDisplay()
{
	return displayTable(displayDate);
}

vector<vector<string>> ProgramController::displayTable(string date)
{
	vector<vector<string>> forTableDisplay;
	forTableDisplay = deployer.getDisplayEvents(date, searchKeywords, displayCase);
	return forTableDisplay;
}

string ProgramController::updateLineText(string inputText, bool isEnterPressed)
{ 
	string completer;
	CommandAndArgumentParser inputParse(inputText);
	command = inputParse.getCommand();
	arguments = inputParse.getArguments();
	if (command == ADD_COMMAND && arguments.empty()) {
		completer = executeAddFormatLineUpdater();
	}
	else if (command == SLOT_COMMAND && arguments.empty()) {
		completer = executeSlotFormatLineUpdater();
	}
	else if (command == EDIT_COMMAND && inputText.substr(inputText.length() - 1, 1) == " " && !isEnterPressed) {
		completer = executeEditLineUpdater(inputText);
	}
	else if (command == CLIP_COMMAND && ((inputText.substr(inputText.length() - 1, 1) == " "  && !isEnterPressed) || isEnterPressed)) {
		completer = executeClipLineUpdater(arguments);
	}
	else if (command == SLOT_COMMAND && isEnterPressed) {
		completer = executeSlotLineUpdater(arguments);
	}
	return completer;
}

string ProgramController::executeAddFormatLineUpdater()
{
	string empty;
	return ADD_FORMAT(empty, empty, empty, empty);
}

string ProgramController::executeSlotFormatLineUpdater()
{
	return SLOT_FORMAT;
}

string ProgramController::executeEditLineUpdater(string inputText)
{
	string completer;
	try {
		EditParser newEdit;
		BaseClassParser * edit = &newEdit;
		int argPosition = edit->convertToPosition(arguments);
		if (argPosition >= 0) {
			string append = deployer.executeFormatContentsToLineEdit(argPosition, displayDate, searchKeywords, displayCase);
			completer = inputText + append;
		}
		return completer;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return completer;
	}
}

string ProgramController::executeClipLineUpdater(string arguments)
{
	string completer;
	try {
		EditParser newEdit;
		BaseClassParser * edit = &newEdit;
		int argPosition = edit->convertToPosition(arguments);
		if (argPosition >= 0)
		{
			string append = deployer.executeFormatContentsToLineEdit(argPosition, displayDate, searchKeywords, displayCase);
			if (!append.empty()) {
				completer = ADD_APPEND + append;
				consoleString = SUCCESS_CLIP(arguments);
			}
			else {
				consoleString = CLIP_ERROR;
			}
		}
		else {
			consoleString = CLIP_ERROR;
		}
		return completer;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return completer;
	}
}

string ProgramController::executeSlotLineUpdater(string arguments)
{
	string completer;
	try {
		SearchParser newSearch;
		BaseClassParser * search = &newSearch;
		dataPackage = search->parsefreeSlotCheck(arguments);
		pair <string, string> result = deployer.executeGetEarliestFreeSlot(dataPackage);
		if (!result.first.empty() && !result.second.empty()) {
			string empty;
			completer = ADD_FORMAT(empty, result.first, result.second, empty);
			consoleString = SLOTS_AVAILABLE(result.first, result.second);
		}
		else {
			consoleString = NO_SLOTS_AVAILABLE;
		}
		return completer;
	}
	catch (const exception& ex){
		consoleString = ex.what();
		return completer;
	}
}

pair<int, int> ProgramController::getCompletedStatToday()
{
	return deployer.executeGetTodayCompletionStat(displayDate);
}

vector<string> ProgramController::returnTestVector()
{
	return deployer.returnTestVector();
}

string ProgramController::getConsoleString()
{
	return consoleString;
}

void ProgramController::clearConsoleString()
{
	consoleString.clear();
	deployer.clearConsoleString();
}

string ProgramController::getTodayDateInString()
{
	time_t t = time(0);   // get time now
	struct tm * now = localtime(&t);

	char buffer[80];
	strftime(buffer, 80, "%d/%m/%Y", now);
	string out = buffer;

	return out;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c\ProgramController.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_fileAccess\FileController.cpp
	 */

#include "stdafx.h"
#include "FileController.h"


FileController::FileController()
{
}


FileController::~FileController()
{
}

bool FileController::checkFile(string fileName)
{
	ofstream myFile(fileName, ios::out | ios::app);

	if (myFile.is_open()) {
		myFile << "";
		myFile.close();
		return true;
	}
	else { return false; }
}

vector<string> FileController::parseFileToMemoryVector(string fileName)
{
	vector<string> toMemory;
	string line;

	ifstream myFile(fileName);

	if (myFile.is_open()) {
		while (getline(myFile, line)) {
			toMemory.push_back(line);
		}
		myFile.close();
	}
	else { return toMemory; }

	return toMemory;
}
bool FileController::cloneMemoryVectorToFile(string fileName, vector<string> memVector)
{
	std::ofstream myFile(fileName);
		if (myFile.is_open()) {
			for (vector<string>::iterator it = memVector.begin(); it != memVector.end(); ++it) {
			myFile << *it << "\n";
		}
		myFile.close();
		return true;
	}
	else {
		return false;
	}
}

string FileController::declareFileAccessError()
{
	return BAD_ACCESS;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_fileAccess\FileController.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_fileAccess\FileEntryFormatter.cpp
	 */

#include "stdafx.h"
#include "FileEntryFormatter.h"


FileEntryFormatter::FileEntryFormatter()
{
}


FileEntryFormatter::~FileEntryFormatter()
{
}

size_t FileEntryFormatter::getAttributedEntryPosition(string attribute, string lineEntry)
{
	string openingAttribute = OPENING_ATTR(attribute);
	size_t foundOpeningAttributeAt = lineEntry.find(openingAttribute);
	size_t attributeEntryStartAt = foundOpeningAttributeAt + openingAttribute.size();
	
	return attributeEntryStartAt;
}

size_t FileEntryFormatter::getAttributeEntrySize(string attribute, string lineEntry)
{
	size_t attributeEntrySize = 0;
	string closingAttribute = CLOSING_ATTR(attribute);
	size_t foundClosingAttributeAt = lineEntry.find(closingAttribute);
	
	if (foundClosingAttributeAt != string::npos) {
		attributeEntrySize = foundClosingAttributeAt - getAttributedEntryPosition(attribute, lineEntry);
	}
	return attributeEntrySize;
}

string FileEntryFormatter::createAttributedEntry(string attribute, string entry)
{
	string openingAttribute = OPENING_ATTR(attribute);
	string closingAttribute = CLOSING_ATTR(attribute);
	string attributedEntry = openingAttribute + entry + closingAttribute;

	return attributedEntry;
}

string FileEntryFormatter::getAttributeEntry(string attribute, string lineEntry)
{
	string attributeEntry = "";
	size_t attributeEntryStartAt = getAttributedEntryPosition(attribute, lineEntry);
	
	if (attributeEntryStartAt != string::npos) {
		size_t attributeEntrySize = getAttributeEntrySize(attribute, lineEntry);
		attributeEntry = lineEntry.substr(attributeEntryStartAt, attributeEntrySize);
	}

	return attributeEntry;
}

string FileEntryFormatter::addAttributedEntryToLineEntry(string attributedEntry, string lineEntry)
{
	lineEntry += attributedEntry;
	return lineEntry;
}

string FileEntryFormatter::deleteAttributedEntryFromLineEntry(string attribute, string lineEntry)
{
	string openingAttribute = OPENING_ATTR(attribute);
	string closingAttribute = CLOSING_ATTR(attribute);
	size_t foundOpeningAttributeAt = lineEntry.find(openingAttribute);
	
	if (foundOpeningAttributeAt != string::npos) {
		size_t attributedEntrySize = openingAttribute.size() +
			getAttributeEntrySize(attribute, lineEntry) + closingAttribute.size();

		lineEntry.erase(foundOpeningAttributeAt, attributedEntrySize);
	}

	return lineEntry;
}

string FileEntryFormatter::editAttributedEntryFromLineEntry(string attribute, string newAttributeEntry, string lineEntry)
{
	size_t attributeEntryStartAt = getAttributedEntryPosition(attribute, lineEntry);

	if (attributeEntryStartAt != string::npos) {
		size_t attributeEntrySize = getAttributeEntrySize(attribute, lineEntry);

		lineEntry.erase(attributeEntryStartAt, attributeEntrySize);

		lineEntry.insert(attributeEntryStartAt, newAttributeEntry);
	}

	return lineEntry;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_fileAccess\FileEntryFormatter.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_fileAccess\MemoryController.cpp
	 */

#include "stdafx.h"
#include "MemoryController.h"


MemoryController::MemoryController()
{
}


MemoryController::~MemoryController()
{
}

vector<string> MemoryController::getVector()
{
	return vectorInMemory;
}

int MemoryController::getVectorSize() 
{
	return vectorInMemory.size();
}

void MemoryController::setVector(vector<string> newVector)
{
	vectorInMemory = newVector;
}

string MemoryController::getLineEntry(int position)
{
	return vectorInMemory[position];
}

void MemoryController::appendLineEntry(string lineEntry)
{
	vectorInMemory.push_back(lineEntry);
}

void MemoryController::insertLineEntry(int position, string line)
{
	int vectorSize = vectorInMemory.size();
	if (position < vectorSize) {
		vector<string>::iterator it;
		it = vectorInMemory.begin() + position;
		vectorInMemory.insert(it, line);
	}
	else {
		appendLineEntry(line);
	}
}

bool MemoryController::deleteLineEntry(int position)
{
	int vectorSize = vectorInMemory.size();
	if (position < vectorSize) {
		vectorInMemory.erase(vectorInMemory.begin() + position);
		return true;
	}
	else { return false; }
}


	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_fileAccess\MemoryController.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\AddLogic.cpp
	 */

#include "stdafx.h"
#include "AddLogic.h"

AddLogic::AddLogic(string fileName) try : BaseClassLogic(fileName)
{
}

catch (const exception& ex)
{
	throw runtime_error(ex.what());
}

AddLogic::AddLogic(vector<string> testVector) : BaseClassLogic(testVector)
{
}

AddLogic::~AddLogic()
{
}

string AddLogic::getLineEntry()
{
	return lineEntry;
}

void AddLogic::appendToLineEntry(string attribute, string entry)
{
	string attributedEntry = createAttributedEntry(attribute, entry);
	lineEntry = addAttributedEntryToLineEntry(attributedEntry, lineEntry);
}

void AddLogic::determineType()
{
	bool isNameEmpty = isParameterStringEmpty(getAttributeEntry(NAME_ATTRIBUTE, lineEntry));
	bool isDateEmpty = isParameterStringEmpty(getAttributeEntry(DATE_ATTRIBUTE, lineEntry));
	bool isStartTimeEmpty = isParameterStringEmpty(getAttributeEntry(START_ATTRIBUTE, lineEntry));
	bool isEndTimeEmpty = isParameterStringEmpty(getAttributeEntry(END_ATTRIBUTE, lineEntry));

	if (isStartTimeEmpty && isEndTimeEmpty && isDateEmpty && isNameEmpty) {
		//do nothing
		//toLog("No type failure")
	}
	else if (isStartTimeEmpty && isEndTimeEmpty && isDateEmpty) {
		appendToLineEntry(TYPE_ATTRIBUTE, FLOAT_TASK_TYPE);
	}
	else if (isStartTimeEmpty && isEndTimeEmpty) {
		lineEntry = editAttributedEntryFromLineEntry(END_ATTRIBUTE, END_OF_DAY_TIME, lineEntry);
		appendToLineEntry(TYPE_ATTRIBUTE, DEADLINE_TASK_TYPE);
	}
	else if (isStartTimeEmpty) {
		appendToLineEntry(TYPE_ATTRIBUTE, DEADLINE_TASK_TYPE);
	}
	else {
		appendToLineEntry(TYPE_ATTRIBUTE, TIMED_TASK_TYPE);
	}
}

void AddLogic::addCompleteEntry()
{
	appendToLineEntry(COMPLETE_ATTRIBUTE, TASK_NOT_COMPLETE);
}

void AddLogic::validChecks() 
{
	determineType();
	if (isParameterStringEmpty(getAttributeEntry(TYPE_ATTRIBUTE, lineEntry))) {
		throw runtime_error(ADD_LOGIC_MISSING_ERROR);
	}
	//toLog("TYPE CHECK PASSED: " + getAttributeEntry(TYPE_ATTRIBUTE, lineEntry));
	if (!isDateAndTimeCorrect(lineEntry)) {
		throw runtime_error(ADD_LOGIC_TIME_DATE_ERROR);
	}
	//toLog("DATE AND TIME CHECK PASSED");
	else {
		string type = getAttributeEntry(TYPE_ATTRIBUTE, lineEntry);
		if (type == "") {
			throw runtime_error(ADD_LOGIC_MISSING_ERROR);
		}
	}
}

void AddLogic::execute(map<string,string> lineEntries)
{
	if (!isTestMode) {
		appendToLineEntry(CREATION_ATTRIBUTE, getTimeNowInString());
	}
	appendToLineEntry(NAME_ATTRIBUTE, lineEntries[NAME_ATTRIBUTE]);
	appendToLineEntry(DATE_ATTRIBUTE, lineEntries[DATE_ATTRIBUTE]);
	appendToLineEntry(START_ATTRIBUTE, lineEntries[START_ATTRIBUTE]);
	appendToLineEntry(END_ATTRIBUTE, lineEntries[END_ATTRIBUTE]);
	appendToLineEntry(CATEGORY_ATTRIBUTE, lineEntries[CATEGORY_ATTRIBUTE]);
	addCompleteEntry();

	try{
		validChecks();
		appendToFile(lineEntry);
		if (isTestMode) {
			updateSortedEntries();
		}
	}
	catch (const exception& ex) {
		throw runtime_error(ex.what());
	}
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\AddLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\BaseClassLogic.cpp
	 */

#include "stdafx.h"
#include "BaseClassLogic.h"

BaseClassLogic::BaseClassLogic(string fileName) try : fileHandler(fileName)
{
}

catch (const exception& ex) 
{
	throw runtime_error(ex.what());
}

BaseClassLogic::BaseClassLogic(vector<string> testVector) : fileHandler(testVector)
{
	isTestMode = true;
}

BaseClassLogic::BaseClassLogic(string fileName, string date, vector<string> keywords, int displayCase) try : fileHandler(fileName)
{
	this->date = date;
	this->keywords = keywords;
	this->displayCase = displayCase;
	updateSortedEntries();
}

catch (const exception& ex)
{
	throw runtime_error(ex.what());
}

BaseClassLogic::BaseClassLogic(vector<string> testVector, string date, vector<string> keywords, int displayCase) : fileHandler(testVector)
{
	this->date = date;
	this->keywords = keywords;
	this->displayCase = displayCase;
	updateSortedEntries();
	isTestMode = true;
}

BaseClassLogic::~BaseClassLogic()
{
}

void BaseClassLogic::toLog(string log)
{
	FileLogic logger("log.txt");
	logger.appendToFile(log);
}

// Start of FileLogic Interface methods
int BaseClassLogic::getEntriesSize()
{
	return fileHandler.getSize();
}

vector<string> BaseClassLogic::getEntriesVector()
{
	return fileHandler.getVector();
}

string BaseClassLogic::getLineFromPositionNumber(int position)
{
	return fileHandler.getLineFromPositionNumber(position);
}

void BaseClassLogic::appendToFile(string lineEntry)
{
	fileHandler.appendToFile(lineEntry);
}

void BaseClassLogic::addToPositionNumber(int position, string lineEntry)
{
	fileHandler.addToPositionNumber(position, lineEntry);
}

void BaseClassLogic::editLine(int position, string newLineEntry)
{
	fileHandler.editLine(position, newLineEntry);
}

void BaseClassLogic::deleteLine(int position) 
{
	fileHandler.deleteLine(position);
}

string BaseClassLogic::createAttributedEntry(string attribute, string entry)
{
	return FileLogic::createAttributedEntry(attribute, entry);
}

string BaseClassLogic::getAttributeEntry(string attribute, string lineEntry)
{
	return FileLogic::getAttributeEntry(attribute, lineEntry);
}

string BaseClassLogic::addAttributedEntryToLineEntry(string attributedEntry, string lineEntry)
{
	return FileLogic::addAttributedEntryToLineEntry(attributedEntry, lineEntry);
}

string BaseClassLogic::deleteAttributedEntryFromLineEntry(string attribute, string lineEntry)
{
	return FileLogic::deleteAttributedEntryFromLineEntry(attribute, lineEntry);
}

string BaseClassLogic::editAttributedEntryFromLineEntry(string attribute, string newAttributeEntry, string lineEntry)
{
	return FileLogic::editAttributedEntryFromLineEntry(attribute, newAttributeEntry, lineEntry);
}
// End of FileLogic Interface methods

// Start of TimeLogic Interface methods
TimeLogic BaseClassLogic::createTimeLogic(string date, string time)
{
	TimeLogic obj(date, time);
	return obj;
}

bool BaseClassLogic::getTimeFormatCheck(TimeLogic obj)
{
	return obj.getTimeFormatCheck();
}

string BaseClassLogic::getStringDate(TimeLogic obj)
{
	return obj.getStringDate();
}

string BaseClassLogic::getStringTime(TimeLogic obj)
{
	return obj.getStringTime();
}

string BaseClassLogic::returnPlusOne(TimeLogic obj)
{
	return obj.returnPlusOne();
}

bool BaseClassLogic::isFirstEarlierThanSecond(TimeLogic time1, TimeLogic time2)
{
	return TimeLogic::isFirstEarlierThanSecond(time1, time2);
}

bool BaseClassLogic::isTimeBeforeNow(TimeLogic time1)
{
	return TimeLogic::isTimeBeforeNow(time1);
}

string BaseClassLogic::getTimeNowInString()
{
	return TimeLogic::getTimeNowInString();
}

TimeLogic BaseClassLogic::addHours(TimeLogic obj, int hours, int min)
{
	obj.addHours(hours, min);
	return obj;
}
// End of TimeLogic Interface methods

vector<string> BaseClassLogic::getSortedLineEntries()
{
	return sortedLineEntries;
}

vector<int> BaseClassLogic::getSortedLinePositions()
{
	return sortedLineFilePositions;
}

void BaseClassLogic::updateSortedEntries()
{
	sortedLineEntries.clear();
	sortedLineFilePositions.clear();
	if (displayCase == 0){
		getListOfEventsHome(date);
	}
	else if (displayCase == -1) {
		getAllEntries();
	}
	else{
		getListOfEventsHaving(keywords);
	}
}

string BaseClassLogic::getDate()
{
	return date;
}

void BaseClassLogic::getListOfEventsHaving(vector<string> keywords)
{
	int size = getEntriesSize();

	for (int i = 0; i < size; ++i) {
		string line = getLineFromPositionNumber(i);
		if (isDateAndTimeCorrect(line)) {
			if (checkKeywordCriteria(line, keywords)) {
				if (getAttributeEntry(TYPE_ATTRIBUTE, line) == FLOAT_TASK_TYPE) {
					sortedLineEntries.push_back(line);
					sortedLineFilePositions.push_back(i);
				}
				else if (!isParameterStringEmpty(getAttributeEntry(TYPE_ATTRIBUTE, line))) {
					addNonFloatEventToEntry(i);
				}
			}
		}
	}
}

void BaseClassLogic::getListOfEventsHome(string fromDate)
{
	int size = fileHandler.getSize();

	TimeLogic dateQualifier = createTimeLogic(date, START_OF_DAY_TIME);

	for (int i = 0; i < size; ++i) {
		string line = getLineFromPositionNumber(i);
		if (isDateAndTimeCorrect(line)) {
			if (getAttributeEntry(TYPE_ATTRIBUTE, line) == FLOAT_TASK_TYPE && getAttributeEntry(COMPLETE_ATTRIBUTE, line) != TASK_COMPLETE) {
				sortedLineEntries.push_back(line);
				sortedLineFilePositions.push_back(i);
			}
			else if (!isParameterStringEmpty(getAttributeEntry(TYPE_ATTRIBUTE, line))) {
				string lineDateString = getAttributeEntry(DATE_ATTRIBUTE, line);
				TimeLogic lineDate = createTimeLogic(lineDateString, START_OF_DAY_TIME);
				if (getAttributeEntry(TYPE_ATTRIBUTE, line) == TIMED_TASK_TYPE){
					string endTime = getAttributeEntry(END_ATTRIBUTE, line);
					lineDate = createTimeLogic(lineDateString, endTime);
				}
				bool isNotCompleted = getAttributeEntry(COMPLETE_ATTRIBUTE, line) == TASK_NOT_COMPLETE;

				if (getTimeFormatCheck(lineDate)) {
					if (isFirstEarlierThanSecond(dateQualifier, lineDate) || isNotCompleted) {
						addNonFloatEventToEntry(i);
					}
				}
			}
		}
	}
}

void BaseClassLogic::getAllEntries()
{
	int size = getEntriesSize();

	for (int i = 0; i < size; ++i) {
		string line = getLineFromPositionNumber(i);
		if (isDateAndTimeCorrect(line)) {
			if (getAttributeEntry(TYPE_ATTRIBUTE, line) == FLOAT_TASK_TYPE) {
				sortedLineEntries.push_back(line);
				sortedLineFilePositions.push_back(i);
			}
			else if (!isParameterStringEmpty(getAttributeEntry(TYPE_ATTRIBUTE, line))) {
				addNonFloatEventToEntry(i);
			}
		}
	}
}

TimeLogic BaseClassLogic::getPriorityDateTime(string line)
{
	string lineDate = getAttributeEntry(DATE_ATTRIBUTE, line);
	string lineTime;
	if (getAttributeEntry(TYPE_ATTRIBUTE, line) == DEADLINE_TASK_TYPE) {
		lineTime = getAttributeEntry(END_ATTRIBUTE, line);
	}
	else if (getAttributeEntry(TYPE_ATTRIBUTE, line) == TIMED_TASK_TYPE) {
		lineTime = getAttributeEntry(START_ATTRIBUTE, line);
	}
	TimeLogic priorityDateTime = createTimeLogic(lineDate, lineTime);
	return priorityDateTime;
}

void BaseClassLogic::addNonFloatEventToEntry(int iteration)
{
	string line = fileHandler.getLineFromPositionNumber(iteration);

	if (sortedLineEntries.size() == 0) {
		sortedLineEntries.push_back(line);
		sortedLineFilePositions.push_back(iteration);
	}
	else {
		vector<string>::iterator it1 = sortedLineEntries.begin();
		vector<int>::iterator it2 = sortedLineFilePositions.begin();
		int minSize = 0;
		int maxSize = sortedLineEntries.size() - 1;

		// Addition of Non-Float Entry is done using binary search to minimise complexity.
		while (maxSize >= minSize) {
			int mid = (minSize + maxSize) / 2;
			string checkLine = sortedLineEntries[mid];

			if (getAttributeEntry(TYPE_ATTRIBUTE, checkLine) == FLOAT_TASK_TYPE) {
				if (maxSize == minSize) {
					sortedLineEntries.insert(it1 + minSize, line);
					sortedLineFilePositions.insert(it2 + minSize, iteration);
					break;
				}
				else {
					maxSize = mid;
				}
			}
			else {
				TimeLogic checkLineTimeLogic = getPriorityDateTime(checkLine);
				TimeLogic deadline = getPriorityDateTime(line);

				bool isEqualDateTime = (checkLineTimeLogic.getStringTime() == deadline.getStringTime()) && (checkLineTimeLogic.getStringDate() == deadline.getStringDate());
				bool isDeadlinePrioritise = (getAttributeEntry(TYPE_ATTRIBUTE, line) == DEADLINE_TASK_TYPE) && (getAttributeEntry(TYPE_ATTRIBUTE, checkLine) == TIMED_TASK_TYPE) && isEqualDateTime;

				if ((isFirstEarlierThanSecond(deadline, checkLineTimeLogic) && !isEqualDateTime) || isDeadlinePrioritise) {
					if (maxSize == minSize) {
						sortedLineEntries.insert(it1 + minSize, line);
						sortedLineFilePositions.insert(it2 + minSize, iteration);
						break;
					}
					else {
						maxSize = mid;
					}
				}
				else {
					if (minSize == maxSize) {
						sortedLineEntries.push_back(line);
						sortedLineFilePositions.push_back(iteration);
						break;
					}
					else {
						minSize = mid + 1;
					}
				}
			}
		}
	}
}

bool BaseClassLogic::checkKeywordCriteria(string line, vector<string> keywords)
{
	bool isCriteriaMet = false;
	int numKeywords = keywords.size();
	for (int i = 0; i < numKeywords && !isCriteriaMet; ++i) {
		string keyword = keywords[i];
		bool isMatchName = getAttributeEntry(NAME_ATTRIBUTE, line) == keyword;
		bool isMatchCategory = getAttributeEntry(CATEGORY_ATTRIBUTE, line) == keyword;

		string lineDate = getAttributeEntry(DATE_ATTRIBUTE, line);
		TimeLogic date = createTimeLogic(lineDate, START_OF_DAY_TIME);

		string lineEnd = getAttributeEntry(END_ATTRIBUTE, line);
		TimeLogic endTime = createTimeLogic(lineDate, lineEnd);

		bool isMatchDate = lineDate == keyword && getTimeFormatCheck(date);
		bool isMatchEndDate = getStringDate(endTime) == keyword && getTimeFormatCheck(endTime);
		
		string lineStart = getAttributeEntry(START_ATTRIBUTE, line);
		TimeLogic startTime = createTimeLogic(lineDate, lineStart);
		bool isMatchStart = lineStart == keyword && getTimeFormatCheck(startTime);
		bool isMatchEnd = getStringTime(endTime) == keyword && getTimeFormatCheck(endTime);

		bool isWithinTime = checkIfTimedTaskWithinTimeKeyword(line, keyword);
		isCriteriaMet = isMatchName || isMatchCategory || isMatchDate || isMatchEndDate || isMatchStart || isMatchEnd || isWithinTime;
	}
	return isCriteriaMet;
}

bool BaseClassLogic::checkIfTimedTaskWithinTimeKeyword(string line, string timeKeyword)
{
	bool isWithinTime = false;
	if (getAttributeEntry(TYPE_ATTRIBUTE, line) == TIMED_TASK_TYPE) {
		string lineDate = getAttributeEntry(DATE_ATTRIBUTE, line);
		string lineStart = getAttributeEntry(START_ATTRIBUTE, line);
		string lineEnd = getAttributeEntry(END_ATTRIBUTE, line);

		TimeLogic startTime = createTimeLogic(lineDate, lineStart);
		TimeLogic endTime = createTimeLogic(lineDate, lineEnd);
		TimeLogic keywordTime = createTimeLogic(lineDate, timeKeyword);

		isWithinTime = isFirstEarlierThanSecond(startTime, keywordTime) && isFirstEarlierThanSecond(keywordTime, endTime);
		if (lineEnd.substr(5, 2) == "+1") {
			TimeLogic keywordTimePlusOne = createTimeLogic(lineDate, timeKeyword + "+1");
			isWithinTime = isFirstEarlierThanSecond(startTime, keywordTimePlusOne) && isFirstEarlierThanSecond(keywordTimePlusOne, endTime);
		}
	}
	return isWithinTime;
}

bool BaseClassLogic::isDateAndTimeCorrect(string lineEntry)
{
	string date = getAttributeEntry(DATE_ATTRIBUTE, lineEntry);
	string startTime = getAttributeEntry(START_ATTRIBUTE, lineEntry);
	string endTime = getAttributeEntry(END_ATTRIBUTE, lineEntry);
	string type = getAttributeEntry(TYPE_ATTRIBUTE, lineEntry);

	bool isDateEmpty = isParameterStringEmpty(getAttributeEntry(DATE_ATTRIBUTE, lineEntry));
	bool isStartTimeEmpty = isParameterStringEmpty(getAttributeEntry(START_ATTRIBUTE, lineEntry));
	bool isEndTimeEmpty = isParameterStringEmpty(getAttributeEntry(END_ATTRIBUTE, lineEntry));

	if (isStartTimeEmpty && isEndTimeEmpty && isDateEmpty && type == FLOAT_TASK_TYPE) {
		return true;
	}
	else if (isStartTimeEmpty && isEndTimeEmpty && type == FLOAT_TASK_TYPE) {
		TimeLogic check = createTimeLogic(date, START_OF_DAY_TIME);
		return getTimeFormatCheck(check);
	}
	else if (isStartTimeEmpty && type == DEADLINE_TASK_TYPE) {
		TimeLogic check = createTimeLogic(date, endTime);
		return getTimeFormatCheck(check);
	}
	else {
		TimeLogic checkStart = createTimeLogic(date, startTime);
		TimeLogic checkEnd = createTimeLogic(date, endTime);

		return (getTimeFormatCheck(checkStart) && getTimeFormatCheck(checkEnd)
			&& isFirstEarlierThanSecond(checkStart, checkEnd) && startTime != endTime);
	}
}

void BaseClassLogic::execute(map<string, string> lineEntries)
{
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
}

void BaseClassLogic::execute(map<string, int> fromToPositions)
{
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
}

void BaseClassLogic::execute(map<string, int> fromToPositions, int executionCase)
{
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
}

void BaseClassLogic::execute(map<string, int> position, map<string, string> lineEntries)
{
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
}

vector<vector<string>> BaseClassLogic::displayEvents()
{
	vector<vector<string>> placeHolder;
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
	return placeHolder;
}

vector<string> BaseClassLogic::createKeywords(string input)
{
	vector<string> placeHolder;
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
	return placeHolder;
}

string BaseClassLogic::formatContentsToLineEdit(int position) 
{
	string placeHolder;
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
	return placeHolder;
}

pair <string, string> BaseClassLogic::getEarliestFreeSlot(map<string, string> fromToTime, map<string, int> duration)
{
	pair <string, string> placeHolder;
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
	return placeHolder;
}

pair <int, int> BaseClassLogic::getTodayCompletionStat(string todayDate)
{
	pair <int, int> placeHolder;
	assert(false && "THIS SHOULD NOT BE ACCESSED!!!");
	return placeHolder;
}

stack<string> BaseClassLogic::getLinesForUndo()
{
	return OldLineEntriesForUndo;
}

stack<int> BaseClassLogic::getPosForUndo()
{
	return oldLinePosforUndo;
}

bool BaseClassLogic::isParameterStringEmpty(string parameter)
{
	return parameter.find_first_not_of(' ') == std::string::npos;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\BaseClassLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\CompleteLogic.cpp
	 */

#include "stdafx.h"
#include "CompleteLogic.h"

CompleteLogic::CompleteLogic(string fileName, string date, vector<string> keywords, int displayCase) try : BaseClassLogic(fileName, date, keywords, displayCase)
{
}

catch (const exception& ex)
{
	throw runtime_error(ex.what());
}

CompleteLogic::CompleteLogic(vector<string> testVector, string date, vector<string> keywords, int displayCase) : BaseClassLogic(testVector, date, keywords, displayCase)
{
}

CompleteLogic::~CompleteLogic()
{
}

void CompleteLogic::editCompletion(int fromPosition, int toPosition, bool complete)
{
	vector<int> positions = getSortedLinePositions();
	int positionSize = positions.size();
	int startPosition = fromPosition - 1;
	int endPosition = toPosition - 1;
	try {
		checkFromToValidity(startPosition, endPosition, positionSize);
		for (int i = startPosition; i <= endPosition; ++i) {
			int filePosition = positions[i];
			storeOldEntryForUndo(filePosition);
			string line = getLineFromPositionNumber(filePosition);
			if (complete) {
				line = editAttributedEntryFromLineEntry(COMPLETE_ATTRIBUTE, TASK_COMPLETE, line);
			}
			else {
				line = editAttributedEntryFromLineEntry(COMPLETE_ATTRIBUTE, TASK_NOT_COMPLETE, line);
			}
			editLine(filePosition, line);
		}
	}
	catch (const exception& ex) {
		throw runtime_error(ex.what());
	}
}

void CompleteLogic::storeOldEntryForUndo(int filePosition)
{
	oldLinePosforUndo.push(filePosition);
	string line = getLineFromPositionNumber(filePosition);
	OldLineEntriesForUndo.push(line);
	//toLog("Undo Storage of Complete passed");
}

void CompleteLogic::checkFromToValidity(int fromPosition, int toPosition, int size)
{
	if (fromPosition >= size || fromPosition < 0 || toPosition >= size || toPosition < 0) {
		//toLog("COMPLETE SLOT OUT OF BOUNDS");
		throw runtime_error(SLOT_IN_EXCESS);
	}
}

void CompleteLogic::execute(map<string, int> fromToPositions, int executionCase)
{
	try {
		if (executionCase == COMPLETE) {
			editCompletion(fromToPositions[FROM_POSITION], fromToPositions[TO_POSITION], true);
		}
		else if (executionCase == UNCOMPLETE) {
			editCompletion(fromToPositions[FROM_POSITION], fromToPositions[TO_POSITION], false);
		}
		else {
			assert(false && "Wrong execution case inserted.");
		}
		if (isTestMode) {
			updateSortedEntries();
		}
	}
	catch (const exception& ex) {
		throw runtime_error(ex.what());
	}
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\CompleteLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\DeleteLogic.cpp
	 */

#include "stdafx.h"
#include "DeleteLogic.h"

DeleteLogic::DeleteLogic(string fileName, string date, vector<string> keywords, int displayCase) try : BaseClassLogic(fileName, date, keywords, displayCase)
{
}

catch (const exception& ex)
{
	throw runtime_error(ex.what());
}

DeleteLogic::DeleteLogic(vector<string> testVector, string date, vector<string> keywords, int displayCase) : BaseClassLogic(testVector, date, keywords, displayCase)
{
}

DeleteLogic::~DeleteLogic()
{
}

void DeleteLogic::checkFromToValidity(int fromPosition, int toPosition, int size)
{
	if (fromPosition >= size || fromPosition < 0 || toPosition >= size || toPosition < 0) {
		throw runtime_error(SLOT_IN_EXCESS);
	}
}

vector<int> DeleteLogic::reAdjustPos(vector<int> pos, int deletedPos)
{
	vector<int> positions = pos;
	int posSize = positions.size();
	for (int i = 0; i < posSize; ++i) {
		if (positions[i] > deletedPos) {
			--positions[i];
		}
		//toLog("New Pos: " + positions[i]);
	}
	return positions;
}

void DeleteLogic::execute(map<string, int> fromToPositions)
{
	vector<int> positions = getSortedLinePositions();
	int positionSize = getSortedLinePositions().size();
	int startPosition = fromToPositions[FROM_POSITION] - 1;
	int toPosition = fromToPositions[TO_POSITION] - 1;
	try {
		checkFromToValidity(startPosition, toPosition, positionSize);
		for (int i = toPosition; i >= startPosition; --i) {
			int filePosition = positions[i];
			storeOldEntryForUndo(filePosition);
			string line = getLineFromPositionNumber(filePosition);
			deleteLine(filePosition);
			positions = reAdjustPos(positions, filePosition);
		}
		if (isTestMode) {
			updateSortedEntries();
		}
	}
	catch (const exception& ex) {
		throw runtime_error(ex.what());
	}
}

void DeleteLogic::storeOldEntryForUndo(int filePosition)
{
	oldLinePosforUndo.push(filePosition);
	string line = getLineFromPositionNumber(filePosition);
	OldLineEntriesForUndo.push(line);
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\DeleteLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\DisplayLogic.cpp
	 */

#include "stdafx.h"
#include "DisplayLogic.h"

DisplayLogic::DisplayLogic(string fileName, string date, vector<string> keywords, int displayCase) try : BaseClassLogic(fileName, date, keywords, displayCase)
{
}

catch (const exception& ex)
{
	throw runtime_error(ex.what());
}

DisplayLogic::DisplayLogic(vector<string> testVector, string date, vector<string> keywords, int displayCase) : BaseClassLogic(testVector, date, keywords, displayCase)
{
}

DisplayLogic::~DisplayLogic()
{
}

vector<string> DisplayLogic::putToVectorEventDatails(string line)
{
	vector<string> eventVector;
	eventVector.push_back(getAttributeEntry(NAME_ATTRIBUTE, line));
	eventVector.push_back(getAttributeEntry(CATEGORY_ATTRIBUTE, line));
	
	string pos2;
	if (getAttributeEntry(START_ATTRIBUTE, line) != "") {
		if (getAttributeEntry(DATE_ATTRIBUTE, line) == getDate()) {
			pos2 = TODAY + getAttributeEntry(START_ATTRIBUTE, line);
		}
		else {
			pos2 = getAttributeEntry(DATE_ATTRIBUTE, line) + " " + getAttributeEntry(START_ATTRIBUTE, line);
		}
	}
	else {
		pos2 = NO_START_STRING;
	}

	string pos3;
	TimeLogic endDate = createTimeLogic(getAttributeEntry(DATE_ATTRIBUTE, line), getAttributeEntry(END_ATTRIBUTE, line));

	if (getStringTime(endDate) != "") {
		if (getStringDate(endDate) == getDate()) {
			pos3 = TODAY + getStringTime(endDate);
		}
		else {
			pos3 = getStringDate(endDate) + " " + endDate.getStringTime();
		}
	}
	else {
		pos2 = FLOAT_START_STRING;
		pos3 = FLOAT_END_STRING;
	}
	eventVector.push_back(pos2);
	eventVector.push_back(pos3);

	bool isNotComplete = getAttributeEntry(COMPLETE_ATTRIBUTE, line) == TASK_NOT_COMPLETE;
	string displayComplete = (isTimeBeforeNow(endDate) && isNotComplete) ? LAPSED : getAttributeEntry(COMPLETE_ATTRIBUTE, line);
	displayComplete = (displayComplete == TASK_COMPLETE || displayComplete == TASK_NOT_COMPLETE || displayComplete == LAPSED) ? displayComplete : UNKNOWN;
	eventVector.push_back(displayComplete);

	return eventVector;
}

vector<vector<string>> DisplayLogic::displayEvents()
{
	vector<vector<string>> toDisplay;
	vector<string> eventList = getSortedLineEntries();
	for (size_t i = 0; i < eventList.size(); ++i) {
		vector<string> parsedEvent = putToVectorEventDatails(eventList[i]);
		toDisplay.push_back(parsedEvent);
	}
	return toDisplay;
}

string DisplayLogic::formatContentsToLineEdit(int position)
{
	const int DDMMYYYY_FULL_LENGTH = 10;
	const int HHMM_FULL_LENGTH = 5;
	const int HHMMPLUS1_FULL_LENGTH = 7;
	const int TIME_DATE_COMP_INPUT_SIZE = 2;
	const int PLUS_ONE_SIZE = 2;
	const int MM_POS = 3;


	string lineAppend;
	vector<string> eventList = getSortedLineEntries();
	int size = eventList.size();
	if (position <= size && position > 0) {
		string line = eventList[position - 1];
		string name = getAttributeEntry(NAME_ATTRIBUTE, line);
		string date = getAttributeEntry(DATE_ATTRIBUTE, line);
		if (date.length() == DDMMYYYY_FULL_LENGTH) {
			date = date.substr(0, TIME_DATE_COMP_INPUT_SIZE) + date.substr(MM_POS, TIME_DATE_COMP_INPUT_SIZE) + date.substr(8, TIME_DATE_COMP_INPUT_SIZE);
		}
		string start = getAttributeEntry(START_ATTRIBUTE, line);
		if (start.length() == HHMM_FULL_LENGTH) {
			start = start.substr(0, TIME_DATE_COMP_INPUT_SIZE) + start.substr(MM_POS, TIME_DATE_COMP_INPUT_SIZE);
		}
		string end = getAttributeEntry(END_ATTRIBUTE, line);
		if (end.length() == HHMM_FULL_LENGTH) {
			end = end.substr(0, TIME_DATE_COMP_INPUT_SIZE) + end.substr(MM_POS, TIME_DATE_COMP_INPUT_SIZE);
		}
		else if (end.length() == HHMMPLUS1_FULL_LENGTH) {
			end = end.substr(0, TIME_DATE_COMP_INPUT_SIZE) + end.substr(MM_POS, TIME_DATE_COMP_INPUT_SIZE + PLUS_ONE_SIZE);
		}
		string category = getAttributeEntry(CATEGORY_ATTRIBUTE, line);

		lineAppend = STRUCT_PARAM_FORMAT(name, date, start + ((start != "") ? TIME_DELIMETER : "") + end, category);
	}
	return lineAppend;
}


	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\DisplayLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\DL_Algorithm.cpp
	 */

#include "stdafx.h"
#include "DL_Algorithm.h"
#include <vector>
#include <map>
#include <climits>


DL_Algorithm::DL_Algorithm()
{
}


DL_Algorithm::~DL_Algorithm()
{
}

int DL_Algorithm::findDLCost(string word, string dictWord) 
{
	if (word.length() == 0) {
		return dictWord.length() * INSERT_COST;
	}
	if (dictWord.length() == 0) {
		return word.length() * DELETE_COST;
	}

	vector<vector<int>> charTable(word.length(), vector<int>(dictWord.length()));

	map<char, int> charIndexSource;
	if (tolower(word.at(0)) != tolower(dictWord.at(0))) {
		charTable[0][0] = min(REPLACE_COST, DELETE_COST + INSERT_COST);
	}
	charIndexSource.insert(pair<char,int>(word.at(0), 0));

	for (size_t i = 1; i < word.length(); ++i) {
		int deleteDist = charTable[i - 1][0] + DELETE_COST;
		int insertDist = (i + 1) * DELETE_COST + INSERT_COST;
		int matchDist = i * DELETE_COST + (tolower(word.at(i)) == tolower(dictWord.at(0)) ? 0 : REPLACE_COST);
		charTable[i][0] = min(min(deleteDist, insertDist), matchDist);
	}

	for (size_t j = 1; j < dictWord.length(); ++j) {
		int deleteDist = (j + 1) * INSERT_COST + DELETE_COST;
		int insertDist = charTable[0][j - 1] + INSERT_COST;
		int matchDist = j * INSERT_COST + (tolower(word.at(0)) == tolower(dictWord.at(j)) ? 0 : REPLACE_COST);
		charTable[0][j] = min(min(deleteDist, insertDist), matchDist);
	}

	for (size_t i = 1; i < word.length(); ++i) {
		int sourceLetterMatchIndexMax = tolower(word.at(i)) == tolower(dictWord.at(0)) ? 0 : -1;
		for (size_t j = 1; j < dictWord.length(); ++j) {
			int swapCandidateIndex = charIndexSource[dictWord.at(j)];
			int jToSwap = sourceLetterMatchIndexMax;
			int deleteDist = charTable[i - 1][j] + DELETE_COST;
			int insertDist = charTable[i][j - 1] + INSERT_COST;
			int matchDistance = charTable[i - 1][j - 1];
			if (tolower(word.at(i)) != tolower(dictWord.at(j))) {
				matchDistance += REPLACE_COST;
			}
			else {
				sourceLetterMatchIndexMax = j;
			}
			
			int distanceSwap;
			if (swapCandidateIndex != NULL && jToSwap != -1) {
				int iToSwap = swapCandidateIndex;
				int beforeSwapCost;
				if (iToSwap == 0 && jToSwap == 0) {
					beforeSwapCost = 0;
				}
				else {
					beforeSwapCost = charTable[max(0, iToSwap - 1)][max(0, jToSwap - 1)];
				}
				distanceSwap = beforeSwapCost + (i - iToSwap - 1) * DELETE_COST + (j - jToSwap - 1) * INSERT_COST + SWAP_COST;
			}
			else {
				distanceSwap = INT_MAX;
			}

			charTable[i][j] = min(min(min(deleteDist, insertDist), matchDistance), distanceSwap);
		}
		charIndexSource.insert(pair<char,int>(tolower(word.at(i)), i));
	}
	return charTable[word.length() - 1][dictWord.length() - 1];
}

	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\DL_Algorithm.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\EditLogic.cpp
	 */

#include "stdafx.h"
#include "EditLogic.h"

EditLogic::EditLogic(string fileName, string date, vector<string> keywords, int displayCase) try : BaseClassLogic(fileName, date, keywords, displayCase)
{
}

catch (const exception& ex)
{
	throw runtime_error(ex.what());
}

EditLogic::EditLogic(vector<string> testVector, string date, vector<string> keywords, int displayCase) : BaseClassLogic(testVector, date, keywords, displayCase)
{
}

EditLogic::~EditLogic()
{
}

void EditLogic::redetermineType()
{
	bool isNameEmpty = isParameterStringEmpty(getAttributeEntry(NAME_ATTRIBUTE, lineEntry));
	bool isDateEmpty = isParameterStringEmpty(getAttributeEntry(DATE_ATTRIBUTE, lineEntry));
	bool isStartTimeEmpty = isParameterStringEmpty(getAttributeEntry(START_ATTRIBUTE, lineEntry));
	bool isEndTimeEmpty = isParameterStringEmpty(getAttributeEntry(END_ATTRIBUTE, lineEntry));

	if (isStartTimeEmpty && isEndTimeEmpty && isDateEmpty && isNameEmpty) {
		lineEntry = editAttributedEntryFromLineEntry(TYPE_ATTRIBUTE, "" , lineEntry);
		//toLog("EDIT TO EMPTY TYPE");
	}
	else if (isStartTimeEmpty && isEndTimeEmpty && isDateEmpty) {
		lineEntry = editAttributedEntryFromLineEntry(TYPE_ATTRIBUTE, FLOAT_TASK_TYPE, lineEntry);
	}
	else if (isStartTimeEmpty && isEndTimeEmpty) {
		lineEntry = editAttributedEntryFromLineEntry(END_ATTRIBUTE, END_OF_DAY_TIME, lineEntry);
		lineEntry = editAttributedEntryFromLineEntry(TYPE_ATTRIBUTE, DEADLINE_TASK_TYPE, lineEntry);
	}
	else if (isStartTimeEmpty) {
		lineEntry = editAttributedEntryFromLineEntry(TYPE_ATTRIBUTE, DEADLINE_TASK_TYPE, lineEntry);
	}
	else {
		lineEntry = editAttributedEntryFromLineEntry(TYPE_ATTRIBUTE, TIMED_TASK_TYPE, lineEntry);
	}
}

void EditLogic::resetCompletion()
{
	lineEntry = editAttributedEntryFromLineEntry(COMPLETE_ATTRIBUTE, TASK_NOT_COMPLETE, lineEntry);
}

void EditLogic::editValidChecks()
{
	redetermineType();
	if (isParameterStringEmpty(getAttributeEntry(TYPE_ATTRIBUTE, lineEntry))) {
		throw runtime_error(EDIT_LOGIC_MISSING_ERROR);
	}
	if (!isDateAndTimeCorrect(lineEntry)) {
		throw runtime_error(EDIT_LOGIC_TIME_DATE_ERROR);
	}
	else {
		string type = getAttributeEntry(TYPE_ATTRIBUTE, lineEntry);
		if (type == "") {
			throw runtime_error(EDIT_LOGIC_MISSING_ERROR);
		}
	}
}

void EditLogic::checkPosValidity(int position, int size)
{
	if (position >= size || position < 0) {
		throw runtime_error(EDIT_SLOT_EXCESS_ERROR);
		//toLog("POS CHECK FAILED");
	}
}

void EditLogic::editEntries(map<string, string> lineEntries)
{
	lineEntry = editAttributedEntryFromLineEntry(NAME_ATTRIBUTE, lineEntries[NAME_ATTRIBUTE], lineEntry);
	lineEntry = editAttributedEntryFromLineEntry(DATE_ATTRIBUTE, lineEntries[DATE_ATTRIBUTE], lineEntry);
	lineEntry = editAttributedEntryFromLineEntry(START_ATTRIBUTE, lineEntries[START_ATTRIBUTE], lineEntry);
	lineEntry = editAttributedEntryFromLineEntry(END_ATTRIBUTE, lineEntries[END_ATTRIBUTE], lineEntry);
	lineEntry = editAttributedEntryFromLineEntry(CATEGORY_ATTRIBUTE, lineEntries[CATEGORY_ATTRIBUTE], lineEntry);
}

void EditLogic::execute(map<string, int> position, map<string, string> lineEntries)
{
	int intPos = position[FROM_POSITION];
	int pos = intPos - 1;
	vector<int> positions = getSortedLinePositions();
	int size = positions.size();
	try {
		checkPosValidity(pos, size);
		int filePosition = positions[pos];
		oldLinePosforUndo.push(filePosition);
		lineEntry = getLineFromPositionNumber(filePosition);
		OldLineEntriesForUndo.push(lineEntry);
		editEntries(lineEntries);
		resetCompletion();
		editValidChecks();
		editLine(filePosition, lineEntry);
		if (isTestMode) {
			updateSortedEntries();
		}
	}
	catch (const exception& ex) {
		throw runtime_error(ex.what());
	}
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\EditLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\FileLogic.cpp
	 */

#include "stdafx.h"
#include "FileLogic.h"

FileLogic::FileLogic(string fileName) : memoryHandler()
{
	this->fileName = fileName;
	try {
		fileAccess();
	}
	catch (const exception& ex) {
		throw runtime_error(ex.what());
	}
}

FileLogic::FileLogic(vector<string> testVector) : memoryHandler()
{
	memoryHandler.setVector(testVector);
	isTestMode = true;
}

FileLogic::~FileLogic()
{
}

int FileLogic::getSize()
{
	return memoryHandler.getVectorSize();
}

vector<string> FileLogic::getVector()
{
	return memoryHandler.getVector();
}

void FileLogic::fileAccess()
{
	if (FileController::checkFile(fileName))
	{
		memoryHandler.setVector(FileController::parseFileToMemoryVector(fileName));
	}
	else {
		throw runtime_error(FILE_ACCESS_ERROR);
	}
}

string FileLogic::getFileName()
{
	return fileName;
}

void FileLogic::changeFile(string fileName)
{
	this->fileName = fileName;
	try {
		fileAccess();
	}
	catch (const exception& ex) {
		throw runtime_error(ex.what());
	}
}

string FileLogic::getLineFromPositionNumber(int position)
{
	if (position < getSize()) {
		return memoryHandler.getLineEntry(position);
	}
	else {
		return "";
	}
}

void FileLogic::appendToFile(string lineEntry)
{
	memoryHandler.appendLineEntry(lineEntry);
	if (!isTestMode) {
		FileController::cloneMemoryVectorToFile(fileName, memoryHandler.getVector());
	}
}

void FileLogic::addToPositionNumber(int position, string lineEntry)
{
	if (getSize() >= position) {
		memoryHandler.insertLineEntry(position, lineEntry);
		if (!isTestMode) {
			FileController::cloneMemoryVectorToFile(fileName, memoryHandler.getVector());
		}
	}
}

void FileLogic::editLine(int position, string lineEntry) 
{
	if (memoryHandler.getVectorSize() > position) {
		memoryHandler.deleteLineEntry(position);
		memoryHandler.insertLineEntry(position, lineEntry);
		if (!isTestMode) {
			FileController::cloneMemoryVectorToFile(fileName, memoryHandler.getVector());
		}
	}
}

void FileLogic::deleteLine(int position)
{
	if (memoryHandler.getVectorSize() > position) {
		memoryHandler.deleteLineEntry(position);
		if (!isTestMode) {
			FileController::cloneMemoryVectorToFile(fileName, memoryHandler.getVector());
		}
	}
}

string FileLogic::createAttributedEntry(string attribute, string entry)
{
	return FileEntryFormatter::createAttributedEntry(attribute, entry);
}

string FileLogic::getAttributeEntry(string attribute, string lineEntry)
{
	return FileEntryFormatter::getAttributeEntry(attribute, lineEntry);
}

string FileLogic::addAttributedEntryToLineEntry(string attributedEntry, string lineEntry)
{
	return FileEntryFormatter::addAttributedEntryToLineEntry(attributedEntry, lineEntry);
}

string FileLogic::deleteAttributedEntryFromLineEntry(string attribute, string lineEntry)
{
	return FileEntryFormatter::deleteAttributedEntryFromLineEntry(attribute, lineEntry);
}

string FileLogic::editAttributedEntryFromLineEntry(string attribute, string newAttributeEntry, string lineEntry)
{
	return FileEntryFormatter::editAttributedEntryFromLineEntry(attribute, newAttributeEntry, lineEntry);
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\FileLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\SearchLogic.cpp
	 */

#include "stdafx.h"
#include "SearchLogic.h"


SearchLogic::SearchLogic(string fileName) try : BaseClassLogic(fileName)
{
}

catch (const exception& ex)
{
	throw runtime_error(ex.what());
}

SearchLogic::SearchLogic(vector<string> testVector) : BaseClassLogic(testVector)
{
}

SearchLogic::~SearchLogic()
{
}
		
vector<string> SearchLogic::createKeywords(string input)
{
	transform(input.begin(), input.end(), input.begin(), ::tolower);

	if (input.length() >= MIMUMUM_LENGTH) {
		int numberOfEvents = getEntriesSize();
		for (int i = 0; i < numberOfEvents; ++i) {
			string line = getLineFromPositionNumber(i);
			checkCategoryMatch(input, line);
			checkNameMatch(input, line);
			checkDateMatch(input, line);
			checkEndTimeMatch(input, line);
			checkTimedTaskMatch(input, line);
		}
		
	}
	return keywords;
}

void SearchLogic::checkTimedTaskMatch(string input, string line)
{
	if (getAttributeEntry(TYPE_ATTRIBUTE, line) == TIMED_TASK_TYPE) {
		if (checkTimedTaskEligibility(input, line)) {
			determinePriority(input, 0);
		}
	}
}

void SearchLogic::checkEndTimeMatch(string input, string line)
{
	DL_Algorithm diffCost;
	string lineDate = getAttributeEntry(DATE_ATTRIBUTE, line);
	string lineEnd = getAttributeEntry(END_ATTRIBUTE, line);
	TimeLogic endDateTime = createTimeLogic(lineDate, lineEnd);
	string endTime = getStringTime(endDateTime);
	int endDifference = diffCost.findDLCost(input, endTime);

	if (endDifference <= DATETIMEMAXCOST)
	{
		if (endDateTime.getTimeFormatCheck()) {
			determinePriority(endTime, endDifference);
		}
	}

}
void SearchLogic::checkDateMatch(string input, string line)
{
	DL_Algorithm diffCost;
	string lineStartDate = getAttributeEntry(DATE_ATTRIBUTE, line);
	string lineEndTime = getAttributeEntry(END_ATTRIBUTE, line);
	
	TimeLogic endDateTime = createTimeLogic(lineStartDate, lineEndTime);
	string lineEndDate = getStringDate(endDateTime);
	
	int lineDateDifference = diffCost.findDLCost(input, lineStartDate);
	int endDateDifference = diffCost.findDLCost(input, lineEndDate);

	if (lineDateDifference <= DATETIMEMAXCOST || endDateDifference <= DATETIMEMAXCOST) {
		TimeLogic dateCheck = createTimeLogic(lineStartDate, START_OF_DAY_TIME);
		if (getTimeFormatCheck(dateCheck) && getTimeFormatCheck(dateCheck)) {
			determinePriority(lineStartDate, lineDateDifference);
			determinePriority(lineEndDate, endDateDifference);
		}
	}
}
void SearchLogic::checkCategoryMatch(string input, string line)
{
	DL_Algorithm diffCost;
	string lineCategory = getAttributeEntry(CATEGORY_ATTRIBUTE, line);
	int categoryDifference = diffCost.findDLCost(input, lineCategory);
	if (categoryDifference <= NONDATETIMEMAXCOST) {
		insertToKeywordVector(input, lineCategory, categoryDifference);
	}
}

void SearchLogic::checkNameMatch(string input, string line)
{
	DL_Algorithm diffCost;
	string lineName = getAttributeEntry(NAME_ATTRIBUTE, line);
	int nameDifference = diffCost.findDLCost(input, lineName);
	if (nameDifference <= NONDATETIMEMAXCOST) {
		insertToKeywordVector(input, lineName, nameDifference);
	}
}

void SearchLogic::insertToKeywordVector(string input, string keyword, int diffCost)
{
	string keywordCopy = keyword;
	transform(keywordCopy.begin(), keywordCopy.end(), keywordCopy.begin(), ::tolower);
	diffCost = (keywordCopy.find(input) != string::npos) ? -1 : diffCost;
	determinePriority(keyword, diffCost);
}

void SearchLogic::determinePriority(string keyword, int diffCost) 
{
	int size = keywords.size();

	bool isCopy = false;
	for (int i = 0; i < size; ++i) {
		string suggestion = keywords[i];
		if (keyword == suggestion) {
			isCopy = true;
			break;
		}
	}

	if (!isCopy) {
		if (keywords.size() == 0) {
			keywords.push_back(keyword);
			keywordPriority.push_back(diffCost);
		}
		else {
			for (int i = 0; i < size; ++i) {
				if (keywordPriority[i] >= diffCost) {
					vector<string>::iterator it1;
					it1 = keywords.begin() + i;
					keywords.insert(it1, keyword);

					vector<int>::iterator it2;
					it2 = keywordPriority.begin() + i;
					keywordPriority.insert(it2, diffCost);

					if (keywords.size() > SUGGESTIONS_LIMIT) {
						keywords.resize(SUGGESTIONS_LIMIT);
					}
					break;
				}
			}
		}
	}
}

bool SearchLogic::checkTimedTaskEligibility(string input, string line)
{
	bool isEligible;

	string date = getAttributeEntry(DATE_ATTRIBUTE, line);
	string start = getAttributeEntry(START_ATTRIBUTE, line);
	string end = getAttributeEntry(END_ATTRIBUTE, line);

	TimeLogic startTime = createTimeLogic(date, start);
	TimeLogic endTime = createTimeLogic(date, end);
	TimeLogic inputTime = createTimeLogic(date, input);

	isEligible = isFirstEarlierThanSecond(startTime, inputTime) && isFirstEarlierThanSecond(inputTime, endTime);
	string dayAddition = end.substr(5, 2);
	if (!isEligible && dayAddition == "+1") {
		TimeLogic inputTimePlusOne = createTimeLogic(date, input + "+1");
		isEligible = isFirstEarlierThanSecond(startTime, inputTimePlusOne) && isFirstEarlierThanSecond(inputTimePlusOne, endTime);
	}
	return isEligible;
}

pair<string, string> SearchLogic::getEarliestFreeSlot(map<string, string> fromToTime, map<string, int> duration)
{
	string date = fromToTime[DATE_ATTRIBUTE];
	string fromTime = fromToTime[START_ATTRIBUTE];
	string toTime = fromToTime[END_ATTRIBUTE];
	int hoursToAdd = duration[FROM_POSITION];
	int minsToAdd = duration[TO_POSITION];

	string start;
	string end;
	if (hoursToAdd <= 23 && minsToAdd <= 59) {
		string iterDate = date;
		string iterTime = fromTime;
		TimeLogic to(date, toTime);

		vector<string> dateKey;
		dateKey.push_back(date);
		getListOfEventsHaving(dateKey);
		vector<string> eventList = getSortedLineEntries();
		int size = eventList.size();
		for (int i = 0; i < size; ++i) {
			string line = eventList[i];
			if (getAttributeEntry(TYPE_ATTRIBUTE, line) == TIMED_TASK_TYPE) {
				//Gets the necessary details.
				string lineDate = getAttributeEntry(DATE_ATTRIBUTE, line);
				string lineStart = getAttributeEntry(START_ATTRIBUTE, line);
				string lineEnd = getAttributeEntry(END_ATTRIBUTE, line);
				//Instantiates the necessary TimeLogic objects.
				TimeLogic lineStartTime = createTimeLogic(lineDate, lineStart);
				TimeLogic lineEndTime = createTimeLogic(lineDate, lineEnd);
				TimeLogic addedTime = createTimeLogic(iterDate, iterTime);
				bool isLineEndingEarlier = isFirstEarlierThanSecond(lineEndTime, addedTime);
				addedTime = addHours(addedTime, hoursToAdd, minsToAdd);

				//If this if block is accessed, free slot is found
				if ((isFirstEarlierThanSecond(addedTime, to) && isFirstEarlierThanSecond(addedTime, lineStartTime))) {
					break;
				}
				//No free slot found yet. Search will shift iterTime to the timed task
				//endtime as new base time.
				else if (!isLineEndingEarlier) {
					iterDate = getStringDate(lineEndTime);
					iterTime = getStringTime(lineEndTime);
					//toLog("At current iteration" + iterDate + " " + iterTime);
				}
			}
		}
		//Checks free slot is within duration after being checked against timed tasks 
		//in event file.
		TimeLogic addedTime = createTimeLogic(iterDate, iterTime);
		addedTime = addHours(addedTime, hoursToAdd, minsToAdd);
		if (isFirstEarlierThanSecond(addedTime, to)) {
			date = iterDate;
			start = iterTime;
			end = getStringTime(addedTime) + returnPlusOne(addedTime);
		}
	}
	string uiDate, uiTime;
	if (!start.empty() && !end.empty()) {
		uiDate = date.substr(0, 2) + date.substr(3, 2) + date.substr(8, 2);
		uiTime = start.substr(0, 2) + start.substr(3, 2) + "-" + end.substr(0, 2) + end.substr(3, end.size()-3);
	}
	pair<string, string> pairTime(uiDate, uiTime);
	return pairTime;
}

pair<int, int> SearchLogic::getTodayCompletionStat(string todayDate)
{
	vector<string> dateKey;
	dateKey.push_back(todayDate);
	getListOfEventsHaving(dateKey);
	vector<string> eventList = getSortedLineEntries();
	int completed = 0;
	int eventsToday = eventList.size();
	for (int i = 0; i < eventsToday; ++i) {
		if (getAttributeEntry(COMPLETE_ATTRIBUTE, eventList[i]) == TASK_COMPLETE) {
			++completed;
		}
	}
	pair<int, int> stats(completed, eventsToday);
	return stats;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\SearchLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\TimeLogic.cpp
	 */

#include "stdafx.h"
#include "TimeLogic.h"
#include <sstream>


TimeLogic::TimeLogic(string date, string time)
{
	stringDate = date;
	stringTime = time;
	checkAndCorrectPlusOne();
	convertStringToTimeLogic(stringDate, stringTime);
}


TimeLogic::~TimeLogic()
{
}

bool TimeLogic::getTimeFormatCheck()
{
	return timeFormatCheck;
}

string TimeLogic::returnPlusOne()
{
	string plusOne;
	if (isPlusOne) {
		plusOne = "+1";
	}
	return plusOne;
}

string TimeLogic::getStringDate()
{
	return stringDate;
}

string TimeLogic::getStringTime()
{
	return stringTime;
}

void TimeLogic::checkAndCorrectPlusOne()
{
	if (stringTime.size() == 7 && stringTime.substr(5, 2) == "+1") {
		stringTime = stringTime.substr(0, 5);
		stringDate = addOneDay(stringDate);
		isPlusOne = true;
	}
}

string TimeLogic::addOneDay(string date)
{
	const char* str = date.c_str();
	int tempYear, tempMonth, tempDay;
	sscanf(str, "%2d/%2d/%4d", &tempDay, &tempMonth, &tempYear);
	if (isDateValid(tempDay, tempMonth, tempYear)) {
		time_t t = time(0);
		struct tm * now = localtime(&t);
		now->tm_year = tempYear - 1900;
		now->tm_mon = tempMonth - 1;
		now->tm_mday = tempDay + 1;
		time_t nextDay = mktime(now);
		struct tm * newDay = localtime(&nextDay);
		char buffer[80];
		strftime(buffer, 80, "%d/%m/%Y", newDay);
		string newDate = buffer;
		return buffer;
	}
	return date;
}

void TimeLogic::addHours(int hours, int mins)
{
	if (hours <= 23 && hours >= 0 && mins <= 59 && mins >= 0) {
		string oldDate = stringDate;
		if (getTimeFormatCheck()) {
			time_t t = time(0);
			struct tm * now = localtime(&t);
			now->tm_year = year - 1900;
			now->tm_mon = month - 1;
			now->tm_mday = day;
			now->tm_hour = hour + hours;
			now->tm_min = min + mins;
			time_t newTime = mktime(now);
			struct tm * newTm = localtime(&newTime);
			char newDt[80];
			strftime(newDt, 80, "%d/%m/%Y", newTm);
			string newDate = newDt;
			if ((newDate != oldDate && !isPlusOne) || newDate == oldDate) {
				if (newDate != oldDate) {
					isPlusOne = true;
				}
				stringDate = newDate;
				char newHHMM[80];
				strftime(newHHMM, 80, "%H:%M", newTm);
				string newTime = newHHMM;
				stringTime = newTime;
				convertStringToTimeLogic(stringDate, stringTime);
			}
		}
	}
}

void TimeLogic::convertStringToTimeLogic(string dateString, string timeString)
{
	if (timeString.size() == 5 && dateString.size() == 10) {
		convertAndInsertDate(dateString);
		if (isDateValid(day, month, year))
		{
			convertAndInsertTime(timeString);
			if (!isTimeValid(hour, min)) {
				timeFormatCheck = false;
			}
		}
		else {
			timeFormatCheck = false;
		}
	}
	else {
		timeFormatCheck = false;
	}
}
void TimeLogic::convertAndInsertDate(string date) 
{
	const char* str = date.c_str();
	sscanf(str, "%2d/%2d/%4d", &day, &month, &year);
}

void TimeLogic::convertAndInsertTime(string time)
{
	const char* str = time.c_str();
	sscanf(str, "%2d:%2d", &hour, &min);
}

bool TimeLogic::isDateValid(int day, int mon, int year)
{
	if (!(2005 <= year))
		return false;
	if (!(1 <= mon && mon <= 12))
		return false;
	if (!(1 <= day && day <= 31))
		return false;
	if ((day == 31) && (mon == 2 || mon == 4 || mon == 6 || mon == 9 || mon == 11))
		return false;
	if ((day == 30) && (mon == 2))
		return false;
	if ((mon == 2) && (day == 29) && (year % 4 != 0))
		return false;
	if ((mon == 2) && (day == 29) && (year % 400 == 0))
		return true;
	if ((mon == 2) && (day == 29) && (year % 100 == 0))
		return false;
	if ((mon == 2) && (day == 29) && (year % 4 == 0))
		return true;

	return true;
}

bool TimeLogic::isTimeValid(int hour, int min) 
{
	if (hour >= 24 || hour < 0) {
		return false;
	}
	if (min >= 60 || min < 0) {
		return false;
	}
	return true;
}

bool TimeLogic::isFirstEarlierThanSecond(TimeLogic time1, TimeLogic time2)
{
	bool boolStore = false;
	if (time1.getTimeFormatCheck() && time2.getTimeFormatCheck()) {
		int iterator = 0;
		int numberEqual = 0;
		int time1Vector[] = { time1.year, time1.month, time1.day, time1.hour, time1.min };
		int time2Vector[] = { time2.year, time2.month, time2.day, time2.hour, time2.min };
		while (iterator < sizeof(time1Vector)) {

			if (!boolStore) {
				boolStore = (time1Vector[iterator] < time2Vector[iterator]);
				if (time1Vector[iterator] > time2Vector[iterator]) {
					break;
				}
			}
			bool isEqual = (time1Vector[iterator] == time2Vector[iterator]);
			if (isEqual) {
				numberEqual++;
			}
			iterator++;
		}
		if (numberEqual == 5) {
			boolStore = true;
		}
	}
	return boolStore;
}

bool TimeLogic::isTimeBeforeNow(TimeLogic time1)
{
	bool boolStore = false;
	if (time1.getTimeFormatCheck()) {
		int iterator = 0;
		time_t t = time(0);   // get time now
		struct tm * now = localtime(&t);
		int todayVector[] = { (now->tm_year + 1900), (now->tm_mon + 1), now->tm_mday, now->tm_hour, now->tm_min };
		int time1Vector[] = { time1.year, time1.month, time1.day, time1.hour, time1.min};
		while (iterator < sizeof(todayVector)) {
			boolStore = (time1Vector[iterator] < todayVector[iterator]);
			if (time1Vector[iterator] != todayVector[iterator]) {
				break;
			}
			iterator++;
		}
	}
	return boolStore;
}

string TimeLogic::getTimeNowInString()
{
	time_t t = time(0);   // get time now
	struct tm * now = localtime(&t);

	char buffer[80];
	strftime(buffer, 80, "%d/%m/%Y %H:%M", now);
	string out = buffer;

	return out;
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\TimeLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\UndoLogic.cpp
	 */

#include "stdafx.h"
#include "UndoLogic.h"

UndoLogic* UndoLogic::_instance = 0;

UndoLogic::UndoLogic()
{
}


UndoLogic::~UndoLogic()
{
}

UndoLogic* UndoLogic::instance()
{
	if (_instance == 0) {
		_instance = new UndoLogic();
	}
	return _instance;
}

void UndoLogic::reset()
{
	_instance = new UndoLogic();
}

bool UndoLogic::isUndoEmpty()
{
	return undoCase.empty();
}

bool UndoLogic::isRedoEmpty()
{
	return redoCase.empty();
}

void UndoLogic::clearRedo()
{
	redoLineStack = stack<stack<string>>();
	redoFilePositionStack = stack<stack<int>>();
	redoCase = stack<string>();
}

void UndoLogic::clearAll()
{
	undoLineStack = stack<stack<string>>();
	undoFilePositionStack = stack<stack<int>>();
	undoCase = stack<string>();
	clearRedo();
}

void UndoLogic::checkFile(string fileName)
{
	if (this->fileName != fileName) {
		this->fileName = fileName;
		clearAll();
	}
}

void UndoLogic::storeUndo(string fileName)
{
	checkFile(fileName);
	clearRedo();
	undoCase.push(ADD_CASE);
	
	FileLogic fileHandler(fileName);
	int position = fileHandler.getSize() - 1;
	string line = fileHandler.getLineFromPositionNumber(position);
	
	stack<string> addString;
	addString.push(line);
	stack<int> positionStack;
	positionStack.push(position);
	
	undoLineStack.push(addString);
	undoFilePositionStack.push(positionStack);
}

void UndoLogic::storeUndo(string fileName, string line, int position)
{
	checkFile(fileName);
	clearRedo();
	undoCase.push(MODIFY_CASE);
	
	stack<string> lineEntry;
	lineEntry.push(line);
	undoLineStack.push(lineEntry);

	stack<int> linePosition;
	linePosition.push(position);
	undoFilePositionStack.push(linePosition);

}

void UndoLogic::storeUndo(string fileName, string commandType, stack<string> lines, stack<int> filePositions)
{
	checkFile(fileName);
	if (commandType == DELETE_CASE) {
		clearRedo();
		undoCase.push(DELETE_CASE);
		undoLineStack.push(lines);
		undoFilePositionStack.push(filePositions);
	}
	else if (commandType == MODIFY_CASE) {
		clearRedo();
		undoCase.push(MODIFY_CASE);
		undoLineStack.push(lines);
		undoFilePositionStack.push(filePositions);
	}
}

void UndoLogic::undo(string fileName)
{
	checkFile(fileName);
	if (!isUndoEmpty()) {
		string caseType = undoCase.top();
		undoCase.pop();
		redoCase.push(caseType);

		if (caseType == ADD_CASE) {
			modify(fileName, UNDO, ADD_CASE);
		}
		else if (caseType == MODIFY_CASE) {
			modify(fileName, UNDO, MODIFY_CASE);
		}
		else if (caseType == DELETE_CASE) {
			modify(fileName, UNDO, DELETE_CASE);
		}
	}
}

void UndoLogic::redo(string fileName)
{
	checkFile(fileName);
	if (!isRedoEmpty()) {
		string caseType = redoCase.top();
		redoCase.pop();
		undoCase.push(caseType);

		if (caseType == ADD_CASE) {
			modify(fileName, REDO, ADD_CASE);
		}
		else if (caseType == MODIFY_CASE) {
			modify(fileName, REDO, MODIFY_CASE);
		}
		else if (caseType == DELETE_CASE) {
			modify(fileName, REDO, DELETE_CASE);
		}
	}
}

void UndoLogic::modify(string fileName, string action, string commandType)
{
	stack<stack<string>> * fromLineStack;
	stack<stack<int>> * fromFilePositionStack;
	stack<stack<string>> * toLineStack;
	stack<stack<int>> * toFilePositionStack;

	if (action == UNDO) {
		fromLineStack = &undoLineStack;
		fromFilePositionStack = &undoFilePositionStack;
		toLineStack = &redoLineStack;
		toFilePositionStack = &redoFilePositionStack;
	}
	else {
		fromLineStack = &redoLineStack;
		fromFilePositionStack = &redoFilePositionStack;
		toLineStack = &undoLineStack;
		toFilePositionStack = &undoFilePositionStack;
	}

	FileLogic fileHandler(fileName);
	stack<string> lines = fromLineStack->top();
	fromLineStack->pop();
	stack<int> positions = fromFilePositionStack->top();
	fromFilePositionStack->pop();

	stack<string> oldLinesStore;
	stack<int> positionsStore;

	while (!lines.empty() && !positions.empty()) {
		string line = lines.top();
		lines.pop();
		int position = positions.top();
		positions.pop();
		positionsStore.push(position);
		if (commandType == MODIFY_CASE || 
		(commandType == DELETE_CASE && action == REDO) ||
		(commandType == ADD_CASE && action == UNDO)) {
			string oldLine = fileHandler.getLineFromPositionNumber(position);
			oldLinesStore.push(oldLine);
			fileHandler.deleteLine(position);
		}
		if (commandType == MODIFY_CASE || 
		(commandType == DELETE_CASE && action == UNDO) ||
		(commandType == ADD_CASE && action == REDO)) {
			if (commandType == DELETE_CASE || commandType == ADD_CASE) {
				oldLinesStore.push(line);
			}
			fileHandler.addToPositionNumber(position, line);
		}
	}
	toLineStack->push(oldLinesStore);
	toFilePositionStack->push(positionsStore);
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_logic\UndoLogic.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestAdd.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include "AddLogic.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace t091c_test
{
	TEST_CLASS(LogicTestAdd)
	{
	public:
		
		TEST_METHOD(ADD_TIMED)
		{
			vector<string> testVector;
			string expected1 = "<name>test1</name><date>05/11/2014</date><start>00:00</start><end>23:59</end><category>test2</category><complete>no</complete><type>timed</type>";
			map<string, string> test1;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "05/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, "00:00"));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "23:59"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test2"));
			AddLogic tester(testVector);
			tester.execute(test1);
			Assert::AreEqual(tester.getLineEntry(), expected1);
		}
		TEST_METHOD(ADD_DEADLINE)
		{
			vector<string> testVector;
			string expected1 = "<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>";
			map<string, string> test1;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "05/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "13:00"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test1"));
			AddLogic tester(testVector);
			tester.execute(test1);
			Assert::AreEqual(tester.getLineEntry(), expected1);
		}
		TEST_METHOD(ADD_DEADLINE_NO_TIME)
		{
			vector<string> testVector;
			string expected1 = "<name>test1</name><date>05/11/2014</date><start></start><end>23:59</end><category>test1</category><complete>no</complete><type>deadline</type>";
			map<string, string> test1;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "05/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(END_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test1"));
			AddLogic tester(testVector);
			tester.execute(test1);
			Assert::AreEqual(tester.getLineEntry(), expected1);
		}
		TEST_METHOD(ADD_FLOAT)
		{
			vector<string> testVector;
			string expected1 = "<name>test1</name><date></date><start></start><end></end><category>test1</category><complete>no</complete><type>float</type>";
			map<string, string> test1;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(START_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(END_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test1"));
			AddLogic tester(testVector);
			tester.execute(test1);
			Assert::AreEqual(tester.getLineEntry(), expected1);
		}
		TEST_METHOD(ADD_WRONG_TIME)
		{
			vector<string> testVector;
			map<string, string> test1;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "05/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "24:00"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test1"));
			AddLogic tester(testVector);
			try {
				tester.execute(test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1[END_ATTRIBUTE] = "23:60";
			try {
				tester.execute(test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}
		TEST_METHOD(ADD_WRONG_DATE)
		{
			vector<string> testVector;
			map<string, string> test1;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "31/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(END_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test1"));
			AddLogic tester(testVector);
			try {
				tester.execute(test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1[DATE_ATTRIBUTE] = "30/13/2014";
			try {
				tester.execute(test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}
	};
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestAdd.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestComplete.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include "CompleteLogic.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace t091c_test
{
	TEST_CLASS(LogicTestComplete)
	{
	public:
		
		TEST_METHOD(COMPLETE_ONE_ENTRY)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			map<string, int> test1Pos;
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			test1Pos.insert(pair<string, int>(TO_POSITION, 1));
			CompleteLogic tester(testVector, "01/11/2014", keywords, displayCase);
			tester.execute(test1Pos, 1);
			string expected = "<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>";
			Assert::AreEqual(expected, tester.getEntriesVector()[0]);
		}
		TEST_METHOD(COMPLETE_MULTIPLE_ENTRIES)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			map<string, int> test1Pos;
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			test1Pos.insert(pair<string, int>(TO_POSITION, 2));
			CompleteLogic tester(testVector, "01/11/2014", keywords, displayCase);
			tester.execute(test1Pos, 1);
			string expected1 = "<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>";
			string expected2 = "<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>yes</complete><type>timed</type>";
			Assert::AreEqual(expected1, tester.getEntriesVector()[0]);
			Assert::AreEqual(expected2, tester.getEntriesVector()[1]);
		}
		TEST_METHOD(COMPLETE_OUT_OF_BOUNDS)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			map<string, int> test1Pos;
			test1Pos.insert(pair<string, int>(FROM_POSITION, 0));
			test1Pos.insert(pair<string, int>(TO_POSITION, 2));
			CompleteLogic tester(testVector, "01/11/2014", keywords, displayCase);
			try {
				tester.execute(test1Pos, 1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1Pos[FROM_POSITION] = 1;
			test1Pos[TO_POSITION] = 3;
			try {
				tester.execute(test1Pos, 1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}

	};
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestComplete.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestDelete.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include "DeleteLogic.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace t091c_test
{
	TEST_CLASS(LogicTestDelete)
	{
	public:
		
		TEST_METHOD(DELETE_ONE_ENTRY)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			map<string, int> test1Pos;
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			test1Pos.insert(pair<string, int>(TO_POSITION, 1));
			DeleteLogic tester(testVector, "01/11/2014", keywords, displayCase);
			tester.execute(test1Pos);
			Assert::IsTrue(tester.getEntriesVector().size() == 0);
		}
		TEST_METHOD(DELETE_ONE_ENTRY_OUT_OF_BOUNDS)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>");
			map<string, int> test1Pos;
			test1Pos.insert(pair<string, int>(FROM_POSITION, 0));
			test1Pos.insert(pair<string, int>(TO_POSITION, 0));
			DeleteLogic tester(testVector, "01/11/2014", keywords, displayCase);
			try {
				tester.execute(test1Pos);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1Pos[TO_POSITION] = 5;
			try {
				tester.execute(test1Pos);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}
		TEST_METHOD(DELETE_MULTIPLE_ENTRIES)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>");
			map<string, int> test1Pos;
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			test1Pos.insert(pair<string, int>(TO_POSITION, 4));
			DeleteLogic tester(testVector, "01/11/2014", keywords, displayCase);
			tester.execute(test1Pos);
			Assert::IsTrue(tester.getEntriesVector().size() == 0);
		}
		TEST_METHOD(DELETE_MULTIPLE_ENTRIES_OUT_OF_BOUNDS)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>");
			map<string, int> test1Pos;
			test1Pos.insert(pair<string, int>(FROM_POSITION, 0));
			test1Pos.insert(pair<string, int>(TO_POSITION, 4));
			DeleteLogic tester(testVector, "01/11/2014", keywords, displayCase);
			try {
				tester.execute(test1Pos);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1Pos[FROM_POSITION] = 1;
			test1Pos[TO_POSITION] = 5;
			try {
				tester.execute(test1Pos);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}
	};
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestDelete.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestEdit.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include "EditLogic.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace t091c_test
{
	TEST_CLASS(LogicTestEdit)
	{
	public:

		TEST_METHOD(EDIT_CONTENT_CHANGE)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>01/11/2014</date><start>00:00</start><end>23:59</end><category>test2</category><complete>no</complete><type>timed</type>");
			string expected1 = "<name>test1</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>";
			map<string, string> test1;
			map<string, int> test1Pos;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "05/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, "13:00"));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "15:00"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test2"));
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			EditLogic tester(testVector,"01/11/2015", keywords, displayCase);
			tester.execute(test1Pos, test1);
			Assert::AreEqual(tester.getEntriesVector()[0], expected1);
		}
		TEST_METHOD(EDIT_CONTENT_TYPE_CHANGE)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>01/11/2014</date><start></start><end>23:59</end><category>test2</category><complete>no</complete><type>deadline</type>");
			string expected1 = "<name>test1</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>";
			map<string, string> test1;
			map<string, int> test1Pos;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "05/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, "13:00"));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "15:00"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test2"));
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			EditLogic tester(testVector, "01/11/2015", keywords, displayCase);
			tester.execute(test1Pos, test1);
			Assert::AreEqual(tester.getEntriesVector()[0], expected1);
		}
		TEST_METHOD(EDIT_CONTENT_OUT_OF_BOUNDS)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>01/11/2014</date><start></start><end>23:59</end><category>test2</category><complete>no</complete><type>deadline</type>");
			map<string, string> test1;
			map<string, int> test1Pos;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "05/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, "13:00"));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "15:00"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test2"));
			test1Pos.insert(pair<string, int>(FROM_POSITION, 0));
			EditLogic tester(testVector, "01/11/2015", keywords, displayCase);
			try {
				tester.execute(test1Pos, test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1Pos[FROM_POSITION] = 2;
			try {
				tester.execute(test1Pos, test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}
		TEST_METHOD(EDIT_CONTENT_WRONG_DATE)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>01/11/2014</date><start></start><end>23:59</end><category>test2</category><complete>no</complete><type>deadline</type>");
			map<string, string> test1;
			map<string, int> test1Pos;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "31/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, "13:00"));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "15:00"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test2"));
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			EditLogic tester(testVector, "01/11/2014", keywords, displayCase);
			try {
				tester.execute(test1Pos, test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1[DATE_ATTRIBUTE] = "01/13/2014";
			try {
				tester.execute(test1Pos, test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}
		TEST_METHOD(EDIT_CONTENT_WRONG_TIME)
		{
			const vector<string> keywords;
			const int displayCase = 0;
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>01/11/2014</date><start></start><end>23:59</end><category>test2</category><complete>no</complete><type>deadline</type>");
			map<string, string> test1;
			map<string, int> test1Pos;
			test1.insert(pair<string, string>(NAME_ATTRIBUTE, "test1"));
			test1.insert(pair<string, string>(DATE_ATTRIBUTE, "30/11/2014"));
			test1.insert(pair<string, string>(START_ATTRIBUTE, ""));
			test1.insert(pair<string, string>(END_ATTRIBUTE, "24:00"));
			test1.insert(pair<string, string>(CATEGORY_ATTRIBUTE, "test2"));
			test1Pos.insert(pair<string, int>(FROM_POSITION, 1));
			EditLogic tester(testVector, "01/11/2014", keywords, displayCase);
			try {
				tester.execute(test1Pos, test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
			test1[END_ATTRIBUTE] = "23:60";
			try {
				tester.execute(test1Pos, test1);
				Assert::IsTrue(false);
			}
			catch (const exception& ex) {
				Assert::IsTrue(true && ex.what());
			}
		}
	};
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestEdit.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestTime.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include "TimeLogic.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace t091c_test
{
	TEST_CLASS(LogicTestTime)
	{
	public:
		
		TEST_METHOD(TIME_COMPARE_CHECK)
		{
			TimeLogic time1test1("01/11/2014", "00:00");
			TimeLogic time2test1("01/11/2014", "00:00+1");
			Assert::IsTrue(TimeLogic::isFirstEarlierThanSecond(time1test1, time2test1));
			TimeLogic time1test2("02/11/2014", "00:00");
			TimeLogic time2test2("01/11/2014", "00:00+1");
			Assert::IsTrue(TimeLogic::isFirstEarlierThanSecond(time1test2, time2test2));
			TimeLogic time1test3("23/11/2014", "00:00");
			TimeLogic time2test3("21/11/2014", "00:00+1");
			Assert::IsFalse(TimeLogic::isFirstEarlierThanSecond(time1test3, time2test3));
		}
		TEST_METHOD(ADD_HOURS_CHECK)
		{
			TimeLogic time1test1("01/11/2014", "00:00");
			time1test1.addHours(3, 33);
			Assert::IsTrue(time1test1.getStringDate() == "01/11/2014");
			Assert::IsTrue(time1test1.getStringTime() == "03:33");
			TimeLogic time1test2("01/11/2014", "00:01");
			time1test2.addHours(23, 59);
			Assert::IsTrue(time1test2.getStringDate() == "02/11/2014");
			Assert::IsTrue(time1test2.getStringTime() == "00:00");
			TimeLogic time1test3("01/11/2014", "00:01+1");
			time1test3.addHours(1, 0);
			Assert::IsTrue(time1test3.getStringDate() == "02/11/2014");
			Assert::IsTrue(time1test3.getStringTime() == "01:01");
			TimeLogic time1test4("01/11/2014", "00:01+1");
			time1test4.addHours(23, 59);
			Assert::IsTrue(time1test4.getStringDate() == "02/11/2014");
			Assert::IsTrue(time1test4.getStringTime() == "00:01");
		}

	};
}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\LogicTestTime.cpp





	/**
	 * origin: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\UnitTestController.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include "SearchParser.h"
#include "TimeParser.h"
#include "ProgramController.h"
#include "ParsedDataDeployer.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace t091c_test
{
	TEST_CLASS(UnitTestController)
	{
	public:
		

		TEST_METHOD(INTEGRATED_TESTING_ADD)
		{
			vector<string> testVector;
			ProgramController test(testVector);
			test.executeEntry("add [test1][051114][1300][test1]");
			string testString1 = "<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>";
			Assert::AreEqual(testString1, test.returnTestVector()[0]);

			test.executeEntry("add [test2][051114][1300-1500][test2]");
			string testString2 = "<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>";
			Assert::AreEqual(testString2, test.returnTestVector()[1]);

			test.executeEntry("add [test3][051114][][test3]");
			string testString3 = "<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>";
			Assert::AreEqual(testString3, test.returnTestVector()[2]);

			test.executeEntry("add [test4][][][test4]");
			string testString4 = "<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>";
			Assert::AreEqual(testString4, test.returnTestVector()[3]);

			test.executeEntry("add [test4][xxx][xxx][test4]");
			size_t vectorSizeTest5 = 4;
			Assert::AreEqual(vectorSizeTest5, test.returnTestVector().size());
		}
		TEST_METHOD(INTEGRATED_TESTING_EDIT)//to show different ways of editing
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>");
			
			ProgramController test(testVector); //edit time
			test.executeEntry("edit 1 [test1][051114][1100][test1]");
			string testString1 = "<name>test1</name><date>05/11/2014</date><start></start><end>11:00</end><category>test1</category><complete>no</complete><type>deadline</type>";
			Assert::AreEqual(testString1, test.returnTestVector()[0]);

			test.executeEntry("edit 2 [test2][051114][1500][test2]");// edit deadline to timed
			string testString2 = "<name>test2</name><date>05/11/2014</date><start></start><end>15:00</end><category>test2</category><complete>no</complete><type>deadline</type>";
			Assert::AreEqual(testString2, test.returnTestVector()[1]);

			test.executeEntry("edit 3 [test2][051114][1500-1700][test2]");//edit name, category and deadline to timed
			string testString3 = "<name>test2</name><date>05/11/2014</date><start>15:00</start><end>17:00</end><category>test2</category><complete>no</complete><type>timed</type>";
			Assert::AreEqual(testString3, test.returnTestVector()[2]);
		}
		TEST_METHOD(INTEGRATED_TESTING_DELETE)//to show basic case that delete single line is working, and borderline cases where delete range exceeds task number range
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>");

			ProgramController test(testVector);
			test.executeEntry("all");
			test.executeEntry("delete 1");
			size_t vectorSizeTest5 = 3;
			Assert::AreEqual(vectorSizeTest5, test.returnTestVector().size());
			test.executeEntry("delete 1 to 4");
			size_t vectorSizeTest6 = 3;
			Assert::AreEqual(vectorSizeTest6, test.returnTestVector().size());
			test.executeEntry("delete 0 to 3");
			size_t vectorSizeTest7 = 3;
			Assert::AreEqual(vectorSizeTest7, test.returnTestVector().size());
			test.executeEntry("delete 1 to 3");
			size_t vectorSizeTest8 = 0;
			Assert::AreEqual(vectorSizeTest8, test.returnTestVector().size());
		}
		TEST_METHOD(INTEGRATED_TESTING_COMPLETE)
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>");

			ProgramController test(testVector);//test for single complete, mass complete and boundary cases
			test.executeEntry("all");
			test.executeEntry("complete 1");
			string expected1 = "<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>";
			Assert::AreEqual(expected1, test.returnTestVector()[0]);
			test.executeEntry("complete 1 to 5");
			Assert::AreEqual(testVector[1], test.returnTestVector()[1]);
			Assert::AreEqual(testVector[2], test.returnTestVector()[2]);
			Assert::AreEqual(testVector[3], test.returnTestVector()[3]);
			test.executeEntry("complete 0 to 3");
			Assert::AreEqual(testVector[1], test.returnTestVector()[1]);
			Assert::AreEqual(testVector[2], test.returnTestVector()[2]);
			Assert::AreEqual(testVector[3], test.returnTestVector()[3]);
			test.executeEntry("complete 1 to 4");
			string expected2 = "<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>yes</complete><type>timed</type>";
			string expected3 = "<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>yes</complete><type>deadline</type>";
			string expected4 = "<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>yes</complete><type>float</type>";
			Assert::AreEqual(expected2, test.returnTestVector()[1]);
			Assert::AreEqual(expected3, test.returnTestVector()[2]);
			Assert::AreEqual(expected4, test.returnTestVector()[3]);
		}
		TEST_METHOD(INTEGRATED_TESTING_UNCOMPLETE)//test for single uncomplete, mass uncomplete and boundary cases
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>yes</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>yes</complete><type>float</type>");

			ProgramController test(testVector);
			test.executeEntry("all");
			test.executeEntry("uncomplete 1");
			string expected1 = "<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>";
			Assert::AreEqual(expected1, test.returnTestVector()[0]);
			test.executeEntry("uncomplete 1 to 5");
			Assert::AreEqual(testVector[1], test.returnTestVector()[1]);
			Assert::AreEqual(testVector[2], test.returnTestVector()[2]);
			Assert::AreEqual(testVector[3], test.returnTestVector()[3]);
			test.executeEntry("uncomplete 0 to 3");
			Assert::AreEqual(testVector[1], test.returnTestVector()[1]);
			Assert::AreEqual(testVector[2], test.returnTestVector()[2]);
			Assert::AreEqual(testVector[3], test.returnTestVector()[3]);
			test.executeEntry("uncomplete 1 to 4");
			string expected2 = "<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>";
			string expected3 = "<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>";
			string expected4 = "<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>";
			Assert::AreEqual(expected2, test.returnTestVector()[1]);
			Assert::AreEqual(expected3, test.returnTestVector()[2]);
			Assert::AreEqual(expected4, test.returnTestVector()[3]);
		}
		TEST_METHOD(INTEGRATED_TESTING_CLIP)
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>yes</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>yes</complete><type>float</type>");
			ProgramController test(testVector);
			test.executeEntry("all");
			string lineText1 = test.updateLineText("clip 1", true);
			string expected1 = "add [test1][051114][1300][test1]";
			Assert::AreEqual(expected1, lineText1);
			string lineText2 = test.updateLineText("clip 4", true);
			string expected2 = "add [test4][][][test4]";
			Assert::AreEqual(expected2, lineText2);
			string lineText3 = test.updateLineText("clip 0", true);
			string expected3 = "";
			Assert::AreEqual(expected3, lineText3);
			string lineText4 = test.updateLineText("clip 5", true);
			string expected4 = "";
			Assert::AreEqual(expected4, lineText4);
		}
		TEST_METHOD(INTEGRATED_TESTING_SEARCH)//filter valid search results
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>yes</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>yes</complete><type>float</type>");
			ProgramController test(testVector);
			vector<string> vector1 = test.populateSuggestionBox("search test");
			Assert::IsTrue(vector1.size() == 4);
			vector<string> vector2 = test.populateSuggestionBox("search xxxxxxx");
			Assert::IsTrue(vector2.size() == 0);
			vector<string> vector3 = test.populateSuggestionBox("search 051114");
			Assert::IsTrue(vector3.size() == 1);
			Assert::IsTrue(vector3[0] == "05/11/2014");
			vector<string> vector4 = test.populateSuggestionBox("search 061114");
			Assert::IsTrue(vector4.size() == 0);
			vector<string> vector5 = test.populateSuggestionBox("search 1300");
			Assert::IsTrue(vector5.size() == 1);
			Assert::IsTrue(vector5[0] == "13:00");
			vector<string> vector6 = test.populateSuggestionBox("search 1301");
			Assert::IsTrue(vector6.size() == 1);
			Assert::IsTrue(vector6[0] == "13:01");
			vector<string> vector7 = test.populateSuggestionBox("search 1259");
			Assert::IsTrue(vector7.size() == 0);
		}
		TEST_METHOD(INTEGRATED_TESTING_SLOT)
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>yes</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>yes</complete><type>float</type>");
			ProgramController test(testVector);
			string lineText1 = test.updateLineText("slot [051114][1500-1700][0200]", true);
			string expected1 = "add [][051114][1500-1700][]";
			Assert::AreEqual(expected1, lineText1);
			string lineText2 = test.updateLineText("slot [051114][1459-1700][0200]", true);
			string expected2 = "add [][051114][1500-1700][]";
			Assert::AreEqual(expected2, lineText2);
			string lineText3 = test.updateLineText("slot [051114][1300-1500][0200]", true);
			string expected3 = "";
			Assert::AreEqual(expected3, lineText3);
			string lineText4 = test.updateLineText("slot [051114][1100-1300][0200]", true);
			string expected4 = "add [][051114][1100-1300][]";
			Assert::AreEqual(expected4, lineText4);
			string lineText5 = test.updateLineText("slot [051114][1200-1600][0200]", true);
			string expected5 = "";
			Assert::AreEqual(expected5, lineText5);
			string lineText6 = test.updateLineText("slot [051114][1200-1700][0200]", true);
			string expected6 = "add [][051114][1500-1700][]";
			Assert::AreEqual(expected6, lineText6);
			string lineText7 = test.updateLineText("slot [051114][1501-1700][0200]", true);//boundary case
			string expected7 = "";
			Assert::AreEqual(expected7, lineText7);
			string lineText8 = test.updateLineText("slot [051114][1500-1501][0001]", true);//boundary case
			string expected8 = "add [][051114][1500-1501][]";
			Assert::AreEqual(expected8, lineText8);
			string lineText9 = test.updateLineText("slot [051114][1700-1500][0200]", true);//flipped
			string expected9 = "";
			Assert::AreEqual(expected9, lineText9);
			string lineText10 = test.updateLineText("slot [051114][0000-2359][1300]", true);//boundary case
			string expected10 = "add [][051114][0000-1300][]";
			Assert::AreEqual(expected10, lineText10);
			string lineText11 = test.updateLineText("slot [051114][0000-2359][2359]", true);//boundary case
			string expected11 = "";
			Assert::AreEqual(expected11, lineText11);

		}
		TEST_METHOD(INTEGRATED_TESTING_DISPLAY_ALL_COMPLETED)
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>yes</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>yes</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>yes</complete><type>float</type>");
			ProgramController test(testVector);
			vector<vector<string>> display1 = test.displayTable("05/11/2014");
			size_t expected1 = 3;
			Assert::AreEqual(display1.size(), expected1);
			vector<vector<string>> display2 = test.displayTable("06/11/2014");
			size_t expected2 = 0;
			Assert::AreEqual(display2.size(), expected2);
		}
		TEST_METHOD(INTEGRATED_TESTING_DISPLAY_NONE_COMPLETED)
		{
			vector<string> testVector;
			testVector.push_back("<name>test1</name><date>05/11/2014</date><start></start><end>13:00</end><category>test1</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test2</name><date>05/11/2014</date><start>13:00</start><end>15:00</end><category>test2</category><complete>no</complete><type>timed</type>");
			testVector.push_back("<name>test3</name><date>05/11/2014</date><start></start><end>23:59</end><category>test3</category><complete>no</complete><type>deadline</type>");
			testVector.push_back("<name>test4</name><date></date><start></start><end></end><category>test4</category><complete>no</complete><type>float</type>");
			ProgramController test(testVector);
			vector<vector<string>> display1 = test.displayTable("05/11/2014");
			size_t expected1 = 4;
			Assert::AreEqual(display1.size(), expected1);
			vector<vector<string>> display2 = test.displayTable("06/11/2014");
			size_t expected2 = 4;
			Assert::AreEqual(display2.size(), expected2);
		}
	};

}
	// End of segment: C:\Users\Marshall\Documents\Visual Studio 2013\Projects\t09-1c\t09-1c_test\UnitTestController.cpp





